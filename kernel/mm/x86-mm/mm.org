#+TITLE: Linux内存管理
#+AUTHOR: Cauchy(pqy7172@gmail.com)
#+OPTIONS: ^:nil
#+EMAIL: pqy7172@gmail.com
#+HTML_HEAD: <link rel="stylesheet" href="../../../org-manual.css" type="text/css">
本文分三大部分来介绍Linux内存管理, 即是:
1) 内存寻址
2) 内存管理
3) 进程地址空间

主要针对的平台是80x86.

* 内存寻址
内存寻址主要解决的问题是: CPU给出一个虚拟地址, 如何将这个虚拟地址转化为RAM的物理地址来索引其中的内容.
** 内存地址
在80x86下要区分三种地址:
1) 逻辑地址

   在机器指令中出现的地址, 指明一个操作数或其它指令的地址. 每个逻辑地址都由一个segment和offest组成, 偏移(offset)指明了实际的地址离段的开始处有多远.
2) 线性地址

   一个32-bit的无符号整数可以索引4GB的地址空间, 也就是4294967296个内存单元. 线性地址通常由十六进制表示, 也就是从0x00000000到0xffffffff.

3) 物理地址

   用来在内存芯片中索引某个内存单元, 其实就是一些会从微处理器发送到内存总线上的电信号. 物理地址由32或36比特的无符号整数来代表.

MMU会将逻辑地址转换为物理地址, 其流程如下:

#+CAPTION: 逻辑地址如何被MMU转化成物理地址
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/process-trans.png]]

在多处理器中, 所有的CPU共享内存, 这意味着RAM芯片或许会被多个独立的芯片并发访问, 在RAM芯片上进行读写是序列化的, 在总线和芯片之间有一个内存仲裁器. 它的作用是, 如果内存芯片是空闲的,
则授予本次访问, 而如果内存芯片正在服务另一个读/写请求, 则拒绝来到的请求. 即使是单处理器,
也需要内存仲裁器. 因为DMA控制器可能会和CPU并发访问内存, 而引起冲突. 但是从编程的角度来说, 仲裁器对他们来说都是不可见的, 是由硬件电路管理的.

** 硬件上的分段
从80286开始, Intel微处理器就分两种方式的地址翻译, 一是实模式, 二是保护模式, 后文的内容主要是针对保护模式开启时的地址翻译. 实模式主要是为了与较旧的处理器兼容以及引导操作系统从实模式过渡到保护模式.
*** 段选择子与段寄存器
一个逻辑地址由两部分组成: 段标识符与偏移, 偏移用来指明在段内的相对地址. 段标识符由16比特组成, 叫做段选择子, 而offset是32比特的域. 关于段选择子后文还要介绍, 而下图是段选择子的结构:

#+CAPTION: 段选择子
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/segment-selector.png]]

为了能够快速的取得段选择子, 在处理器内部有段寄存器用来存放段选择子, 这些寄存器被叫做cs,
ss, ds, es, fs以及gs. 尽管只有较少的六个, 程序可以把它们存到内存上, 从而重用这些寄存器, 待用完后又可以从内存里恢复它们的值.

其中有三个段寄存器是有特别的目的:

1) cs

   代码段寄存器, 指向一个包含有程序指令的段.

2) ss

   栈段寄存器, 指向一个包含当前栈的段.

3) ds

   数据段寄存器, 指向一个包含有全局或静态数据的段.

其余三个寄存器就是通用目的了, 可以指向任意的数据段.

cs寄存器还有一个重要的功能, 它有两个bit域用来表明CPU的当前权限级(Current Privilege
Level,CPL). 0表示最高的权限级, 而3表示最低的权限级, Linux仅使用0和3, 即所谓的内核模式和用户模式.

*** 段描述符
每个段由八字节的段描述符来表示，这个段描述符描述了段的特性。段描述符存在全局描述符表或局部描述符表中。

全局描述符表（GDT，Global Descriptor Table）通常只有一个，但局部描述符表（LDT，Local Descriptor
Table）可能会有多个。GDT在内存里的地址和占有的大小通常是存在gdtr控制寄存器里，而当前正在使用的LDT的地址与大小存放在ldtr控制寄存器里。

下图展示了段描述符的格式：

#+CAPTION: 段描述符格式
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/segment-selector-format.png]]

下面这个表解释了各个字段的意义：
| 字段名 | 描述                                                                                                                                                                                |
|--------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Base   | 所描述段的第一字节的线性地址。                                                                                                                                                      |
| G      | 粒度标志：如果是0，段的大小以字节为单位，如果为1则是4096字节的倍数。                                                                                                                |
| Limit  | 存放段的最后字节的偏移，也即是指明了段的长度，如果G是0，大小介于1B-1MB，否则是4KB-4GB。                                                                                             |
| S      | 系统标志：如果是0，代表这是一个系统段，存放有关键数据结构比如局部描述符表，否则，则是一个正常的代码或数据段。                                                                       |
| Type   | 指明段的类型以及访问权限                                                                                                                                                            |
| DPL    | Descriptor Privilege Level，用来限制对段的访问。指明了访问段的最小权限级别。当段的DPL是0时，这时仅有CPL是0，即CPU处于Kernel Mode时才可访问，然而DPL为3时，就可被任意级别的CPL访问。 |
| P      | 段存在标志。为0时，代表段存在于内存中。Linux总是把这个flag设为1，代表它从未将段swap out到磁盘。                                                                                     |
| D or B | 依据段是包含代码还是数据，代码段为D，数据段为B。                                                                                                                                    |
| AVL    | 或许被操作系统使用，Linux不用。                                                                                                                                                                  |

由于有几种类型段，也有对应的几种段描述符。下面列出了几种在Linux中广泛使用的段描述符类型：
1) 代码段描述符
   
   表示段描述符指向的是一个代码段，这种类型的段描述符可以存放在全局描述符表GDT中，也可以存放在局部描述符表LDT中。描述符的S标志被设置为1，表明这是一个非系统段。
2) 数据段描述符

   表示段描述符指向的是一个数据段，这种类型的段描述符可以存放在全局描述符表GDT中，也可以存放在局部描述符表LDT中。描述符的S标志被设置为1，表明这是一个非系统段。栈段在实现上是通过普通的数据段来做到的。
3) 任务状态段描述符（TSSD）

   表明这个段描述符指向一个任务状态段，这个段是用来存放处理器（进程的）寄存器的内容。仅在GDT中存放，根据对应的进程是否正在CPU上运行，其对应的Type域有值11或9。它的S标志自然是0，代表这是一个系统段。
4) 局部描述符表描述符（LDTD）

   表示段描述符指向一个包含有LDT的段，仅在GDT中存放，Type域的值为2。S标志为0，代表所指段为
   系统段。后文会介绍在80x86下，如何决定一个段描述符是存放在GDT中还是LDT中。
*** 快速访问段描述符
前文已述，逻辑地址由16-bit的段选择子和32-bit的偏移组成，段寄存器用来存放段选择子。

为了加速逻辑地址到线性地址的翻译，在80x86下，对于每个可编程的段寄存器，都有一个不可编程的（程序员不可见）寄存器，这个不可编程的寄存器都存放有由对应的段寄存器里的段选择子所指明的段描述符。每当段选择子加载到段寄存器时，其对应的段描述符也会由内存加载到对应的不可编程寄存器里。这时，访问响应段里的逻辑地址时就可以不用访问存在内存中的GDT或LDT。处理器可以直接从CPU寄存器里获得相应段选择子的段描述符。只有当段寄存器的内容改变时，才有必要访问GDT或LDT。如下图：

#+CAPTION: 段选择子与段描述符
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/selector-descriptor.png]]

任何段选择子都包含如下表的三个域：
| 域名 | 描述                                                           |
|------+----------------------------------------------------------------|
| 索引 | 指明是在GDT或LDT中的哪个条目                                   |
| TI   | Table Indictor：指明描述符是包含在GDT（TI=0）还是LDT（TI=1）中 |
| RPL  | Requestor Privilege Level：当段选择子被加载到cs寄存器时，RPL就成了CPU的Current Privilege Level。 |


由于段描述符是8字节长，那么一个段描述符在GDT或LDT中的相对位置是将13-bit的索引值乘以8后得到。比如，GDT存在0x00020000位置（在gdtr寄存器中）而由段选择子指明的索引是2，那么对应的段描述符的地址就是0x00020000 + （2X8），即是0x00020010。

GDT的第一个条目通常设为0。这可以保证逻辑地址为NULL时，可以被当成非法，因此触发处理器异常。
在GDT中能存放最大数目的段选择子是8191个（2**13 - 1）。
*** 分段单元
下图详细的展示了一个逻辑地址如何被转换为一个线性地址。分段单元执行下面的操作：
#+CAPTION: 将逻辑地址转换为线性地址
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 25% :height 25%
[[./img/log-addr-trans.png]]

1) 通过检查段选择子中的TI域来确定哪一个描述符表存有段描述符。这个域会指明描述符要么存在GDT（这种情况下，分段单元通过gdtr寄存器来获得GDT表的基地址）中要么存在激活的LDT（这种情况下，分段单元通过ldtr寄存器来获得LDT表的基地址）中。
2) 从段选择子中的index域来获得段描述符的地址。index域的值会乘以8（一个段描述符的大小），并且会加到gdtr或ldtr寄存器。
3) 将逻辑地址的偏移和段描述符的Base域相加，由此而得到线性地址。

要注意下的是，由于每个段寄存器都有一个与之关联的不可编程寄存器存有段描述符，所以头两步只有段寄存器发生改变时才会被执行。
** Linux中的分段
分段在80x86微处理器中得到支持，这鼓励程序员把他们的应用划分为逻辑相关的部分，比如子程序或者、全局以及局部数据区域。然而，Linux却很少使用分段。实际上，分段和分页在某种程度上是冗余的，因为两者都可以划分进程的物理地址空间：分段可以分配给每个进程不同的线性地址空间，而分页可以将相同的线性地址空间映射到不同的物理地址空间。Linux更加偏爱分页而不是分段，因为：

- 当所有进程都使用相同的段寄存器时，也就是它们共享相同的线性地址空间，内存管理就会变得更加简单。
- Linux的一个设计目的就是可移植性，尽量移植到更多的架构。而RISC对于分段支持的不是很好。

所有在User Mode下运行的进程，使用user code segment和user data segment来寻址指令和
数据。类似的，所有在Kernel Mode下运行的进程，使用kernel code segment和kernel data segment
来寻址指令和数据。下面的表描述了对于这四个段描述符的各个域：
| Segment     |       Base | G |   Limit | S | Type | DPL | D/B | P |
|-------------+------------+---+---------+---+------+-----+-----+---|
| user code   | 0x00000000 | 1 | 0xfffff | 1 |   10 |   3 |   1 | 1 |
| user data   | 0x00000000 | 1 | 0xfffff | 1 |    2 |   3 |   1 | 1 |
| kernel code | 0x00000000 | 1 | 0xfffff | 1 |   10 |   0 |   1 | 1 |
| kernel data | 0x00000000 | 1 | 0xfffff | 1 |    2 |   0 |   1 | 1 |
对应的段描述符由四个宏定义，分别是__USER_CS、__USER_DS、__KERNEL_CS以及__KERNEL_DS。为了寻址内核代码段，内核就加载由__KERNEL_CS宏决定的值到cs段寄存器。

注意这些段的线性地址都是从0开始到2**32-1，这意味着所有的进程，不论是在User Mode还是Kernel Mode下都可能使用相同的逻辑地址。

另外在Linux下，逻辑地址和线性地址是重合的，也就是逻辑地址的offset域就对应着线性地址。

如前所述，CPU的当前权限级表明了处理器是在User模式还是Kernel模式下，并且是由存在cs寄存器中段选择子的RPL域指明。CPL如果改变，对应的某些段寄存器就可能会更新，比如，CPL是3（User Mode）
的话，ds寄存器就必须包含user data segment的段选择子。当CPL是0的时候，ds寄存器就必须包含kernel data segment的段选择子。

对于ss寄存器也有类似的情形，当CPL为3时，必须引用用户模式的栈，为0就是内核模式的栈了。当从用户模式切换到内核模式时，Linux总是确保ss寄存器包含内核数据段的段选择子。


*** Linux GDT
*** Linux LDTs
** 硬件上的分页
** Linux中的分页
* 内存管理
* 进程地址空间
