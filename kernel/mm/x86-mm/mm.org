#+TITLE: Linux内存管理
#+AUTHOR: Cauchy(pqy7172@gmail.com)
#+OPTIONS: ^:nil
#+EMAIL: pqy7172@gmail.com
#+HTML_HEAD: <link rel="stylesheet" href="../../../org-manual.css" type="text/css">
本文分三大部分来介绍Linux内存管理, 即是:
1) 内存寻址
2) 内存管理
3) 进程地址空间

主要针对的平台是80x86.

* 内存寻址
内存寻址主要解决的问题是: CPU给出一个虚拟地址, 如何将这个虚拟地址转化为RAM的物理地址来索引其中的内容.
** 内存地址
在80x86下要区分三种地址:
1) 逻辑地址

   在机器指令中出现的地址, 指明一个操作数或其它指令的地址. 每个逻辑地址都由一个segment和offest组成, 偏移(offset)指明了实际的地址离段的开始处有多远.
2) 线性地址

   一个32-bit的无符号整数可以索引4GB的地址空间, 也就是4294967296个内存单元. 线性地址通常由十六进制表示, 也就是从0x00000000到0xffffffff.

3) 物理地址

   用来在内存芯片中索引某个内存单元, 其实就是一些会从微处理器发送到内存总线上的电信号. 物理地址由32或36比特的无符号整数来代表.

MMU会将逻辑地址转换为物理地址, 其流程如下:

#+CAPTION: 逻辑地址如何被MMU转化成物理地址
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/process-trans.png]]

在多处理器中, 所有的CPU共享内存, 这意味着RAM芯片或许会被多个独立的芯片并发访问, 在RAM芯片上进行读写是序列化的, 在总线和芯片之间有一个内存仲裁器. 它的作用是, 如果内存芯片是空闲的,
则授予本次访问, 而如果内存芯片正在服务另一个读/写请求, 则拒绝来到的请求. 即使是单处理器,
也需要内存仲裁器. 因为DMA控制器可能会和CPU并发访问内存, 而引起冲突. 但是从编程的角度来说, 仲裁器对他们来说都是不可见的, 是由硬件电路管理的.

** 硬件上的分段
从80286开始, Intel微处理器就分两种方式的地址翻译, 一是实模式, 二是保护模式, 后文的内容主要是针对保护模式开启时的地址翻译. 实模式主要是为了与较旧的处理器兼容以及引导操作系统从实模式过渡到保护模式.
*** 段选择子与段寄存器
一个逻辑地址由两部分组成: 段标识符与偏移, 偏移用来指明在段内的相对地址. 段标识符由16比特组成, 叫做段选择子, 而offset是32比特的域. 关于段选择子后文还要介绍, 而下图是段选择子的结构:

#+CAPTION: 段选择子
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/segment-selector.png]]

为了能够快速的取得段选择子, 在处理器内部有段寄存器用来存放段选择子, 这些寄存器被叫做cs,
ss, ds, es, fs以及gs. 尽管只有较少的六个, 程序可以把它们存到内存上, 从而重用这些寄存器, 待用完后又可以从内存里恢复它们的值.

其中有三个段寄存器是有特别的目的:

1) cs

   代码段寄存器, 指向一个包含有程序指令的段.

2) ss

   栈段寄存器, 指向一个包含当前栈的段.

3) ds

   数据段寄存器, 指向一个包含有全局或静态数据的段.

其余三个寄存器就是通用目的了, 可以指向任意的数据段.

cs寄存器还有一个重要的功能, 它有两个bit域用来表明CPU的当前权限级(Current Privilege
Level,CPL). 0表示最高的权限级, 而3表示最低的权限级, Linux仅使用0和3, 即所谓的内核模式和用户模式.

*** 段描述符
每个段由八字节的段描述符来表示，这个段描述符描述了段的特性。段描述符存在全局描述符表或局部描述符表中。

全局描述符表（GDT，Global Descriptor Table）通常只有一个，但局部描述符表（LDT，Local Descriptor
Table）可能会有多个。GDT在内存里的地址和占有的大小通常是存在gdtr控制寄存器里，而当前正在使用的LDT的地址与大小存放在ldtr控制寄存器里。

下图展示了段描述符的格式：

#+CAPTION: 段描述符格式
#+ATTR_HTML: :align centering
#+ATTR_HTML: :width 50% :height 50%
[[./img/segment-selector-format.png]]

下面这个表解释了各个字段的意义：
| 字段名 | 描述                                                                                                                                                                                |
|--------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Base   | 所描述段的第一字节的线性地址。                                                                                                                                                      |
| G      | 粒度标志：如果是0，段的大小以字节为单位，如果为1则是4096字节的倍数。                                                                                                                |
| Limit  | 存放段的最后字节的偏移，也即是指明了段的成都，如果G是0，大小介于1B-1MB，否则是4KB-4GB。                                                                                             |
| S      | 系统标志：如果是0，代表这是一个系统段，存放有关键数据结构比如局部描述符表，否则，则是一个正常的代码或数据段。                                                                       |
| Type   | 指明段的类型以及访问权限                                                                                                                                                            |
| DPL    | Descriptor Privilege Level，用来限制对段的访问。指明了访问段的最小权限级别。当段的DPL是0时，这时仅有CPL是0，即CPU处于Kernel Mode时才可访问，然而DPL为3时，就可被任意级别的CPL访问。 |
| P      | 段存在标志。为0时，代表段存在于内存中。Linux总是把这个flag设为1，代表它从未将段swap out到磁盘。                                                                                     |
| D or B | 依据段是包含代码还是数据，代码段为D，数据段为B。                                                                                                                                    |
| AVL    | 或许被操作系统使用，Linux不用。                                                                                                                                                                  |

由于有几种类型段，也有对应的几种段描述符。下面列出了几种在Linux中广泛使用的段描述符类型：
1) 代码段描述符
2) 数据段描述符
3) 任务状态段描述符
4) 局部描述符表描述符
*** 快速访问段描述符
** Linux中的分段
** 硬件上的分页
** Linux中的分页
* 内存管理
* 进程地址空间
