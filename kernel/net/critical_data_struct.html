<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2021-06-02 Wed 23:19 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>关键数据结构</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../org-manual.css" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">关键数据结构</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc3368e9">1. 套接字缓存：sk_buff结构体</a>
<ul>
<li><a href="#orgeeb3596">1.1. 网络选项与内核结构体</a></li>
<li><a href="#org9da5020">1.2. 字段布局</a></li>
<li><a href="#org7a9d7ad">1.3. 通用字段</a></li>
<li><a href="#org2e099b5">1.4. 功能相关的域</a></li>
<li><a href="#org71670b5">1.5. 管理函数</a>
<ul>
<li><a href="#org27c01f5">1.5.1. 分配内存：alloc_skb以及dev_alloc_skb</a></li>
<li><a href="#orgda90a0d">1.5.2. 释放内存：kfree_skb和dev_kfree_skb</a></li>
<li><a href="#orgbecf903">1.5.3. 数据预留和对齐：skb_reserve、skb_put、skb_push以及skb_pull</a></li>
<li><a href="#org95a17f0">1.5.4. 数据克隆与拷贝</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org09d9c12">2. net_device结构体</a></li>
</ul>
</div>
</div>
<p>
在阅读本系列的后续文章和研究内核网络代码时，会不时参考几个关键结构，自然对其中的各个域也要有一定的理解。
</p>

<p>
本文会介绍下面这些数据结构，并且会提及某些操作这些数据结构的函数和宏：
</p>
<ul class="org-ul">
<li><p>
struct sk_buff
</p>

<p>
用于存放一个packet。该结构体会被所有网络层用到，存放头部信息，用户数据（负载payload）信息，以及其它需要协调工作的信息。
</p></li>

<li><p>
struct net_device
</p>

<p>
在内核中的网络设备都由这个结构体表示，它包含有硬件以及软件配置信息。后面的系列文章会介绍它的分配。
</p></li>
</ul>

<p>
另外还有一个关键数据结构是struct sock，它用来存储套接字的网络信息，不过这不是本系列文章的重点。
</p>
<div id="outline-container-orgc3368e9" class="outline-2">
<h2 id="orgc3368e9"><span class="section-number-2">1</span> 套接字缓存：sk_buff结构体</h2>
<div class="outline-text-2" id="text-1">
<p>
这个结构体或许是Linux内核网络里最重要的数据结构了，表示了到达或要传输数据的的头部信息，定义在include/linux/skbuff.h文件里，这个结构体包含了大量的成员。
</p>

<p>
在内核开发的历史上，这个结构体改变了许多次，包括添加新的选项，重排已经存在的成员，这些域大致可以分为以下四类：
</p>
<ul class="org-ul">
<li>布局</li>
<li>通用</li>
<li>特定功能相关的</li>
<li>管理函数</li>
</ul>

<p>
这个结构体会被几个不同的网络层（包括MAC或者其它在第二层的链路层协议，L3层上的IP，L4层上的TCP或UDP）使用到，并且随着包从一层传到另一层，结构体中的各个域也会改变。在L4层把包传给L3层
之前, 会附加一个头部信息, 而L3层在传到L2层时, 也会附加它的头. 比起将数据从一层拷贝到另一层,
只附加头部信息, 效率就很高. 因为向一个buffer的头部处添加空间(通过操作指向这个buffer的变量)是一个比较复杂的操作, 内核提供skb_reserve函数来完成这个功能. 因此到每个协议层时, 要做的第一件事就是调用skb_reserve函数来为协议预留头部信息. 在后面的小节里我们会看到一个例子, 当缓存在层之间传递时, 内核是如何确保在缓存的头部预留足够多的空间.
</p>

<p>
当缓存(数据)在协议栈由底向上传递时, 底层(旧)的头部信息就不再需要了. 举例来说, L2层的头部信息, 仅由设备驱动层使用, L3层并不关心. 不过内核代码并不是直接从缓存(数据)中直接删除L2层的头部信息, 只是将指向payload的指针向前移动到L3的头部信息处, 这样消耗的CPU周期就比较少.
</p>
</div>

<div id="outline-container-orgeeb3596" class="outline-3">
<h3 id="orgeeb3596"><span class="section-number-3">1.1</span> 网络选项与内核结构体</h3>
<div class="outline-text-3" id="text-1-1">
<p>
配置内核或查看TCP/IP的spec时, 网络代码都会提供许多有用的选项但并不是必须的, 比如防火墙, 多
播以及其它的功能. 这些选项大多数都要求在内核的数据结构里增加更多的域. 因此在sk_buff里随处
可见C的预处理宏#ifdef. 比如在sk_buff结构体的底部, 可以看到这样的代码部分:
</p>

<div class="org-src-container">
<pre class="src src-C++">...
<span style="color: #94BFF3;">#ifdef</span> CONFIG_NET_SCHED
  __u32 tc_index;
<span style="color: #94BFF3;">#ifdef</span> CONFIG_NET_CLS_ACT
  <span style="color: #7CB8BB;">__32</span> <span style="color: #DFAF8F;">tc_verd</span>;
  <span style="color: #7CB8BB;">__u32</span> <span style="color: #DFAF8F;">tc_classid</span>;
<span style="color: #94BFF3;">#endif</span>
<span style="color: #94BFF3;">#endif</span>
</pre>
</div>

<p>
这个例子就展示了只有在编译时定义了CONFIG_NET_SCHED符号时tc_index域才是sk_buff结构体的一部分. 这就是说, 系统管理员使用make config或者使用自动安装工具, 将Device Drivres-&gt;Networking support-&gt;Networking options-&gt;Qos and/or fair queueing选项打开了.
</p>

<p>
这个例子实际上展示了两个嵌套的选项, CONFIG_NET_CLS_ACT下的成员只有在QoS and/or fair
queueing选项得到支持时才考虑加入到sk_buff结构体里来.
</p>

<p>
需要注意的是, QoS选项不能被编译成模块的形式. 因为使能这个选项后, 对于内核数据结构的影响通
常是不可逆的. 一般来说, 那些会造成内核数据结构有改变的选项都不适合编译成模块.
</p>
</div>
</div>

<div id="outline-container-org9da5020" class="outline-3">
<h3 id="org9da5020"><span class="section-number-3">1.2</span> 字段布局</h3>
<div class="outline-text-3" id="text-1-2">
<p>
sk_buff里有几个成员, 只是为了帮助搜索和组织数据结构本身, 内核在双向链表里维护sk_buff结构体.
但是这个链表的组织比传统的要复杂些.
</p>

<p>
像其它双链表一样, 通过next和prev域来连接这些sk_buff结构体. 而sb_buff有一个特殊的要求就是要能快速的找到整个链表的头. 为了达到这个目的, 一个sk_buff_head类型的成员放在了链表的开头. 其定义如下:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff_head</span> {
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span> *<span style="color: #DFAF8F;">next</span>;
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span> *<span style="color: #DFAF8F;">prev</span>;
<span style="color: #7CB8BB;">__u32</span> <span style="color: #DFAF8F;">qlen</span>;
<span style="color: #7CB8BB;">spinlock_t</span> <span style="color: #DFAF8F;">lock</span>;
}
</pre>
</div>

<p>
qlen代表列表中有多少个元素. lock用来防止同时访问列表, 后面还会介绍.
</p>

<p>
sk_buff和sk_buff_head的前两个元素是一样的: next和prev指针. 另外sk_buff还包括一个list域用来指向sk_buff_head. 如下的图:
</p>


<div class="figure">
<p><img src="./img/sk_buff_head_rel.png" alt="sk_buff_head_rel.png" width="30%" height="30%" align="centering">
</p>
<p><span class="figure-number">Figure 1: </span>sk_buff和sk_buff_head之间的关系</p>
</div>

<p>
其它的一些域:
</p>

<ul class="org-ul">
<li><p>
struct sock *sk
</p>

<p>
指向拥有这个sk_buff的套接字. 当数据在本地生成或被本地进程接收时, 就需要这个域. 因为数据本身和套接字相关的信息被L4层(TCP或UDP)以及用户程序所使用. 当这个buffer仅仅是转发(forward)时, 也就是源和目的地都不在本机, 这个指针就是NULL.
</p></li>

<li><p>
unsigned int len
</p>

<p>
在buffer中数据的大小. 这个长度包括被head所指的主buffer里的数据, 以及分段(fragments)中的数据. 它的值会随着buffer在网络协议栈上移动而变化, 比如沿协议栈向上时, 头部就会被丢弃, 而沿协议栈向下时, 头部就会被添加上. 当然, len是算上了协议头部的. 关于这一点后面还会介绍.
</p></li>

<li><p>
unsigned int data_len
</p>

<p>
与len不同的是, data_len仅仅计算在分段中的数据长度.
</p></li>

<li><p>
unsigned int mac_len
</p>

<p>
链路层(MAC)的头部长度.
</p></li>

<li><p>
refcount_t users
</p>

<p>
记录了有多少个实体正在使用sk_buff结构体. 使用这个成员主要是为了防止还在使用sk_buff时而被释放了. 每个使用这个结构体的用户都应该增加这个域, 并且在必要的时候递减这个域. 需要注意的是, 这个域仅是包含对sk_buff本身引用的计数, 而对于由sk_buff包含数据的计数在skb_shared_info或skb_shinfo中一个相似的域: dataref来计数, 后面会介绍这点.
</p>

<p>
user有时直接使用atomic_inc或atomic_dec来直接加减, 但是大多数时候是通过skb_get或kfree_skb来操作.
</p></li>

<li><p>
unsigned int truesize
</p>

<p>
表示了buffer的总大小, 要算上sk_buff结构体自身的大小. 当buffer在alloc_skb函数里请求分配len字节大小的时候, 这个域就会被初始化成len+sizeof(sk_buff):
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span> *<span style="color: #93E0E3;">alloc_skb</span>(<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">size</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">gfp_mask</span>)
{
  ...
  skb-&gt;truesize = size + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span>);
  ...
}
</pre>
</div>

<p>
当skb-&gt;len更新时, 这个域也要更新.
</p></li>

<li>unsigned char *head</li>
<li>unsigned char *end</li>
<li>unsigned char *data</li>
<li><p>
unsigned char *tail
</p>

<p>
这些域划分了buffer以及在其中的数据的边界. 当各层操作它们自己的数据时, 可能会给header或数据本身分配更多空间. head和end指向分配buffer的开始以及结尾处, 而data和tail指向实际数据的开始与结束处. 如下图所示:
</p></li>
</ul>


<div class="figure">
<p><img src="./img/head-end-data-tail.png" alt="head-end-data-tail.png" width="50%" height="50%" align="centering">
</p>
<p><span class="figure-number">Figure 2: </span>head/end和data/tail之间的对比</p>
</div>

<p>
网络协议栈上的某层可以将它自己的协议header填到head与data之间. 而在tail和end之间还可以填充尾部信息. 
</p>

<ul class="org-ul">
<li><p>
void (*destructor)(&#x2026;)
</p>

<p>
当一个buffer被移除时, 这个成员所指的函数会执行某些动作. 当buffer不属于一个套节字时,
destructor通常不会被初始化. 当buffer属于某个套接字时, 这个成员通常会被初始化为sock_rfree
或sock_wfree(分别由skb_set_owner_r或skb_set_owner_w初始化).
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org7a9d7ad" class="outline-3">
<h3 id="org7a9d7ad"><span class="section-number-3">1.3</span> 通用字段</h3>
<div class="outline-text-3" id="text-1-3">
<p>
下面介绍一些sk_buff主要的域，这些域不和内核特定的feature关联。
</p>
<ul class="org-ul">
<li><p>
tsamp
</p>

<p>
包到达或离开的时间。
</p></li>

<li><p>
struct net_device *dev
</p>

<p>
表示一个网络设备，后面还会详细介绍。dev结构体充当的角色作用，依赖于存在buffer里的数据是要被传送的还是刚到达的。
</p>

<p>
当包是到达的时候，设备驱动会更新这个域，以一个指向代表接受包的网卡设备。
</p>

<p>
当包准备被发送出去时，dev就表示发送包的设备。
</p>

<p>
某些网络功能，允许多个设备聚合在一起成为一个虚拟的设备，这个虚拟的设备不直接和具体的硬件关联起来。当设备驱动被调用时，dev成员指向虚拟设备的net_device结构体。驱动程序会从这组硬件设备相关的dev结构体中选择一个dev。换言之，指向传输设备的指针在包处理的过程中可能会改变。
</p></li>

<li><p>
char cb[40]
</p>

<p>
控制buffer，或者用来存储私有信息，由每一层维护，自己内部使用。在sk_buff里静态分配。在各层的代码里，访问这个成员通过宏来做，这使得代码可读性更好。比如对TCP来说，就用来存储tcp_skb_cb结构体。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">tcp_skb_cb</span> {
  ...
  __u32     seq;        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Starting sequence number</span><span style="color: #5F7F5F;"> */</span>
  <span style="color: #7CB8BB;">__u32</span>     <span style="color: #DFAF8F;">end_seq</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">SEQ + FIN + SYN + datalen</span><span style="color: #5F7F5F;">    */</span>
  <span style="color: #F0DFAF; font-weight: bold;">union</span> {
      <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Note : tcp_tw_isn is used in input path only</span>
<span style="color: #7F9F7F;">       *      (isn chosen by tcp_timewait_state_process())</span>
<span style="color: #7F9F7F;">       *</span>
<span style="color: #7F9F7F;">       *      tcp_gso_segs/size are used in write queue only,</span>
<span style="color: #7F9F7F;">       *      cf tcp_skb_pcount()/tcp_skb_mss()</span>
<span style="color: #5F7F5F;">       */</span>
      <span style="color: #7CB8BB;">__u32</span>     <span style="color: #DFAF8F;">tcp_tw_isn</span>;
      <span style="color: #F0DFAF; font-weight: bold;">struct</span> {
          <span style="color: #7CB8BB;">u16</span>   <span style="color: #DFAF8F;">tcp_gso_segs</span>;
          <span style="color: #7CB8BB;">u16</span>   <span style="color: #DFAF8F;">tcp_gso_size</span>;
      };
  };
}
...
</pre>
</div>

<p>
下面这个宏被用来访问这个结构体，这个宏其实就是简单的指针转换：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">TCP_SKB_CB</span>(<span style="color: #DFAF8F;">__skb</span>)   ((<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">tcp_skb_cb</span> *)&amp;((__skb)-&gt;cb[0]))
</pre>
</div></li>

<li>unsigned int csum</li>
<li><p>
unsigned char ip_summed
</p>

<p>
校验和以及关联的状态标志。
</p></li>

<li><p>
unsigned char cloned
</p>

<p>
一个boolean标志，当设置时，表示这个结构体是另一个结构体的拷贝。
</p></li>

<li><p>
unsigned char pkt_type
</p>

<p>
基于L2层的目的地址而划分帧的类型。对于以太网设备来说，这个参数由函数eth_type_trans设置，后面还会介绍。
</p>

<p>
主要可能的值包括：
</p>

<ul class="org-ul">
<li><p>
PACKET_HOST
</p>

<p>
收到的帧的目的地址就是接收接口，换句话说，包已经到达了目的地址。
</p></li>

<li><p>
PACKET_MULTICAST
</p>

<p>
收到的帧的目的地址是一个注册的多播地址。
</p></li>

<li><p>
PACKET_BROADCAST
</p>

<p>
收到帧的目的地址是一个广播地址。
</p></li>

<li><p>
PACKET_OTHERHOST
</p>

<p>
收到帧的目的地址不属于接收的这个卡。这时，如果forward（转发）打开了的话，就转发，否则丢弃。
</p></li>

<li><p>
PACKET_LOOPBACK
</p>

<p>
包是发送到回环（loopback）设备上。由于这个flag，当处理回环设备的包时，相比真实的设备内核会跳过一些操作。
</p></li>

<li><p>
PACKET_FASTROUTE
</p>

<p>
包通过fastroute功能进行路由，fastroute在2.6以后内核被支持。
</p></li>
</ul></li>

<li><p>
__u32 priority
</p>

<p>
这个成员表示了一个要被传送或转发包的QoS等级（Quality of Service）。如果包是在本地机器生成的，由socket层来定义priority值。而如果是转发的包，rt_tos2priority会根据IP头里的ToS（Type of Service）来填这个priority，是由ip_forward调用rt_tos2priority完成的。
</p></li>

<li><p>
__be16 protocol;
</p>

<p>
表示了在设备驱动层（L2）看到的上一层，典型的值有：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">ETH_P_IP</span>    0x0800      <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Internet Protocol packet</span><span style="color: #5F7F5F;"> */</span>
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">ETH_P_IPV6</span>  0x86DD      <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">IPv6 over bluebook</span><span style="color: #5F7F5F;">       */</span>
</pre>
</div>

<p>
每种协议都有它自己的处理接受包的函数，该字段由驱动使用用来通知上层使用哪个函数句柄。每个驱动都会调用netif_rx来调用上层的句柄。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org2e099b5" class="outline-3">
<h3 id="org2e099b5"><span class="section-number-3">1.4</span> 功能相关的域</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Linux是模块化的，可以允许什么被包括进内核，什么不被包括进内核。因此仅当内核被编译为支持某些功能的时候才会将sk_buff里某些成员包括进内核。比如对于Netfiler或QoS来说就是这样。
</p>
</div>
</div>

<div id="outline-container-org71670b5" class="outline-3">
<h3 id="org71670b5"><span class="section-number-3">1.5</span> 管理函数</h3>
<div class="outline-text-3" id="text-1-5">
<p>
内核提供了很多简短的函数用来操纵sk_buff里的元素或者是操作sk_buff列表。在下图的帮助下，本节会介绍几个这样的函数：
</p>


<div id="org641caa3" class="figure">
<p><img src="./img/skb_ops.png" alt="skb_ops.png" width="30%" height="30%">
</p>
<p><span class="figure-number">Figure 3: </span>skb操纵函数操作前后，(a): skb_put，(b): skb_push，（c）：skb_pull，(d): skb_reserve</p>
</div>

<p>
首先会介绍到的是分配与释放buffer，随后是操作skb-&gt;data的指针用来在一个帧的head或tail处预留空间。
</p>

<p>
在内核里经常会看到两个版本的函数，它们的名字像这样：do_something或__do_something。通常前一个函数是第二个的包装函数，它会做一些检查或锁相关的事情。通常内部的__do_something函数不会被直接调用，除非特定的条件满足的话。
</p>
</div>

<div id="outline-container-org27c01f5" class="outline-4">
<h4 id="org27c01f5"><span class="section-number-4">1.5.1</span> 分配内存：alloc_skb以及dev_alloc_skb</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
alloc_skb实现了分配buffer，定义在skbuff.c里。前述已表达数据buffer（data buffer）和头（header）是两个不同的实体，这意味着创造一个buffer涉及到内存的两次分配，一次是数据buffer一次是sk_buff结构体。
</p>

<p>
alloc_skb从kmem_cache里获得sk_buff结构体，通过调用函数kmem_cache_alloc_node函数来完成获取。而data buffer是通过kmalloc来获取的，如果cache memory可用的话，kmalloc同样通过cache。代码类似于下面这样（简化过）：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kmem_cache</span> *<span style="color: #DFAF8F;">cache</span>;
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span> *<span style="color: #DFAF8F;">skb</span>;
...
skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~GFP_DMA, node);
size = SKB_DATA_ALIGN(size);
size += SKB_DATA_ALIGN(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">skb_shared_info</span>));
data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);
</pre>
</div>

<p>
在调用kmalloc_reserve之前，size参数使用SKB_DATA_ALIGN宏来进行对齐。在返回之前，alloc_skb会初始化sk_buff的成员，最后的效果如下图：
</p>

<div id="org1635b07" class="figure">
<p><img src="./img/after_alloc_skb.png" alt="after_alloc_skb.png" width="50%" height="50%">
</p>
<p><span class="figure-number">Figure 4: </span>alloc_skb函数完成后</p>
</div>

<p>
在上图右半部分的下部，可以看到为了对齐而添加的padding区域。而skb_shared_info主要用于处理IP分段，后面还会再介绍。
</p>

<p>
dev_alloc_skb主要是被设备驱动使用，而且可以在中断模式下使用。
</p>
</div>
</div>


<div id="outline-container-orgda90a0d" class="outline-4">
<h4 id="orgda90a0d"><span class="section-number-4">1.5.2</span> 释放内存：kfree_skb和dev_kfree_skb</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
这两个函数用于释放缓存，这会导致将sk_buff放回到buffer池（pool）。最后一个真正会释放sk_buff的调用是当skb-&gt;users为1时。不然该函数只是将users这个counter减1。比如如果一个buffer有三个使用者，仅当第三次调用这些释放函数时才会真正释放内存。
</p>

<p>
下面的图展示了释放一个buffer的流程。在后面的文章中可以看到sk_buff可以引用到dst_entry数据结构。当sk_buff结构体释放时，dst_release也会被调用以减少到dst_entry的引用。
</p>


<div id="org326aec1" class="figure">
<p><img src="./img/kfree_skb.png" alt="kfree_skb.png" width="35%" height="35%">
</p>
<p><span class="figure-number">Figure 5: </span>kfree_skb函数</p>
</div>


<p>
当析构器（destructor）被初始化时，此时也会调用。
</p>

<p>
在前面有看到，sk_buff会关联到另一个内存数据块，这是实际存放数据的地方。然而在这个数据块的底部是skb_shared_info结构体，它可以包含指向其它内存块的指针。kfree_skb也会释放这些内存。最后sk_buff会返回给skbuff_head_cache。
</p>
</div>
</div>

<div id="outline-container-orgbecf903" class="outline-4">
<h4 id="orgbecf903"><span class="section-number-4">1.5.3</span> 数据预留和对齐：skb_reserve、skb_put、skb_push以及skb_pull</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
skb_reserve用来在buffer的头部处预留某些空间，在插入头或对齐数据边界时经常用到。这个函数会移动data和tail指针，data和tail分别确定了payload的开始和结束位置。如图 <a href="#org641caa3">3</a> 所示展示了调用skb_reserve后的情况。这个函数通常是在分配buffer不久后调用，这时data和tail还是一样的，此时再预留一部分头部空间，注意在没有填充payload时，data和tail依旧是指向一样的位置。
</p>

<p>
如果阅读以太网驱动代码的话（比如3c59x.c文件），在刚分配buffer而存放任何实际数据前经常可以看到下面的调用：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">skb_reserve</span>(skb, 2);
</pre>
</div>

<p>
因为Ethernet frame具有14B长是已知的，上述调用会在头部处多shift出来2B，这就可以保持IP
header紧邻ethernet frame之后从而对齐在16-byte字节边界处。如下图：
</p>


<div id="org8e7c3b5" class="figure">
<p><img src="./img/skb_reserve.png" alt="skb_reserve.png" width="50%" height="50%">
</p>
<p><span class="figure-number">Figure 6: </span>skb_reserve操作前后</p>
</div>

<p>
下面的图展示了相反方向的buffer变化：也就是数据传输方向。
</p>


<div id="org2581ee0" class="figure">
<p><img src="./img/buffer_to_link.png" alt="buffer_to_link.png" width="50%" height="50%">
</p>
<p><span class="figure-number">Figure 7: </span>buffer从TCP层传到link层时是如何变化的</p>
</div>

<ol class="org-ol">
<li>当TCP被要求去传输数据时，它会分配符合一定标准大小的buffer，比如TCP Maximum Segment
Size(mss)。</li>
<li>TCP使用skb_reserve函数在buffer的头部预留足够多的空间去存放各层的头（包括TCP，IP以及链路层）。MAX_TCP_HEADER是考虑了最坏情况下的所有层的所有header大小：TCP并不知道其下什么接口会用来传输数据，就预留每层可能的最大header空间，甚至会考虑多IP头的情况（当内核被编译为支持IP over IP时，就可以有多个IP header）。</li>

<li>TCP层的负载被拷贝到buffer里。注意上图只是个例子，TCP负载的组织可以不同，比如它可以组织成fragment的形式。</li>
<li>TCP可以添加它的header了。</li>
<li>TCP现在终于把buffer传递到了下层的IP层，IP层加上了它自己的header。</li>
<li>IP层又交给它的邻居下层，链路层会添加Ethernet头部。</li>
</ol>

<p>
buffer在网络栈从上到下传递时，每层的协议都将skb-&gt;data向下移动，然后拷贝它这一层的头，并且更新skb-&gt;len。这些操作通过前面介绍过的skb操作函数来完成。
</p>

<p>
注意skb_reserve并没有真正的往buffer里放入任何东西，它仅仅是更新两个指针。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">skb_reserve</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span> *<span style="color: #DFAF8F;">skb</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">len</span>)
{
    skb-&gt;data += len;
    skb-&gt;tail += len;
}
</pre>
</div>

<p>
skb_push在buffer之起始处放置数据，而skb_put在末尾添加数据。和skb_reserve类似，这些函数也没有真的添加数据，都是简单的在head和tail处移动指针，数据的拷贝由其它函数完成。而skb_pull从Head处移除数据，当然也只是移动指针了。
</p>

<p>
如图
<a href="#org1635b07">4</a>
所示，在data buffer的最后，有一个skb_shared_info结构体用来存储额外的信息。下面是这个结构体的定义：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">skb_shared_info</span> {
    <span style="color: #7CB8BB;">__u8</span>        <span style="color: #DFAF8F;">flags</span>;
    <span style="color: #7CB8BB;">__u8</span>        <span style="color: #DFAF8F;">meta_len</span>;
    <span style="color: #7CB8BB;">__u8</span>        <span style="color: #DFAF8F;">nr_frags</span>;
    <span style="color: #7CB8BB;">__u8</span>        <span style="color: #DFAF8F;">tx_flags</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">short</span>  <span style="color: #DFAF8F;">gso_size</span>;
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Warning: this field is not always filled in (UFO)!</span><span style="color: #5F7F5F;"> */</span>
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">short</span>  <span style="color: #DFAF8F;">gso_segs</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sk_buff</span>  *<span style="color: #DFAF8F;">frag_list</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">skb_shared_hwtstamps</span> <span style="color: #DFAF8F;">hwtstamps</span>;
    <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span>    <span style="color: #DFAF8F;">gso_type</span>;
    <span style="color: #7CB8BB;">u32</span>     <span style="color: #DFAF8F;">tskey</span>;

    <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">     * Warning : all fields before dataref are cleared in __alloc_skb()</span>
<span style="color: #5F7F5F;">     */</span>
    <span style="color: #7CB8BB;">atomic_t</span>    <span style="color: #DFAF8F;">dataref</span>;

    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Intermediate layers must ensure that destructor_arg</span>
<span style="color: #7F9F7F;">     * remains valid until skb destructor</span><span style="color: #5F7F5F;"> */</span>
    <span style="color: #7CB8BB;">void</span> *      <span style="color: #DFAF8F;">destructor_arg</span>;

    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">must be last field, see pskb_expand_head()</span><span style="color: #5F7F5F;"> */</span>
    <span style="color: #7CB8BB;">skb_frag_t</span>  <span style="color: #DFAF8F;">frags</span>[MAX_SKB_FRAGS];
};
</pre>
</div>

<p>
dataref代表了这个buffer block有多少个用户。在后面会讨论nr_frags，frag_list以及frags用来处理IP分段。skb_is_nonlinear可以用来检查buffer是否被分段。而skb_linearize*用来将多个分段组成一个单一的buffer。组合单个fragments涉及拷贝，这引入了性能延迟。
</p>

<p>
某些网卡，可以处理传统上属于CPU处理的任务，最常见的例子就是计算L3和L4层的校验和，某些网卡甚至能维护L4层的状态机。对于这里要展示的代码，仅关心TCP分段卸载，即由NIC实现了TCP层的部分功能，gso_size和gso_seqs使用了这个特点。
</p>

<p>
注意在sk_buff里没有成员是指向sk_shared_info结构体的。为了访问这个结构体，需要使用skb_shinfo宏。
</p>

<p>
比如下面的代码，展示了如何递增nr_frags++：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">skb_shinfo</span>(skb)-&gt;nr_frags++;
</pre>
</div>
</div>
</div>

<div id="outline-container-org95a17f0" class="outline-4">
<h4 id="org95a17f0"><span class="section-number-4">1.5.4</span> 数据克隆与拷贝</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
当数据需要由不同的消费者独立的处理时，它们各自可能需要改变sk_buff描述符的内容，内核可以不必完全的拷贝整个sk_buff结构体和关联的data buffer。为效率考虑计，内核可以clone原来的数据结构，即只是增加引用计数（reference count）而避免过早的释放数据块。buffer克隆通过函数skb_clone来做。一个需要使用克隆的情况是进入的包需要被递送到多个接受者，比如协议句柄和更多的网络tap（后文介绍tap）。
</p>

<p>
克隆出来的buffer没有链接到任何list上，也没有属于任何socket。在克隆出来和原来的buffer里，
skb-&gt;cloned成员都被设置成1。下图展示了一个clone出来的buffer：
</p>

<div id="org4164e3d" class="figure">
<p><img src="./img/skb_func.png" alt="skb_func.png" width="50%" height="50%">
</p>
<p><span class="figure-number">Figure 8: </span>skb_clone函数的效果</p>
</div>

<p>
可以看到上图表示了一个分段的buffer，但是现在不需要关心这个细节。
</p>

<p>
当一个buffer被clone时，数据块的内容是不能更改的。这就是说代码可以访问数据而不需要锁机制。
当函数不仅需要修改sk_buff而且需要修改buffer数据时，这就需要也clone数据块。当程序员知道仅需
要修改skb-&gt;start和skb-&gt;end之间的内容时，可以使用pskb_copy函数。当他认为还可能修改分段的数
据块时，就要用skb_copy函数了。这两个函数的操作结果如下图：
</p>

<div id="org9651d7d" class="figure">
<p><img src="./img/pskb_copy_and_skb_copy.png" alt="pskb_copy_and_skb_copy.png" width="50%" height="50%">
</p>
<p><span class="figure-number">Figure 9: </span>(a)pskb_copy和skb_copy函数</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org09d9c12" class="outline-2">
<h2 id="org09d9c12"><span class="section-number-2">2</span> net_device结构体</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2021-06-02 Wed 23:19</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
