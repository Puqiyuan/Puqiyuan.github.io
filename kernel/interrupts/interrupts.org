#+TITLE: 中断与异常
#+AUTHOR: Cauchy(pqy7172@gmail.com)
#+OPTIONS: ^:nil
#+EMAIL: pqy7172@gmail.com
#+HTML_HEAD: <link rel="stylesheet" href="../../org-manual.css" type="text/css">

本文讲述Linux的中断和异常。

中断通常定义为可以修改指令流的事件。这些事件都对应着电信号，电信号的可以来自CPU芯片内部或外部。

中断通常可以划分为两类，同步与异步，所谓同/异步：
- 同步中断：
  1) 由CPU控制单元发出。
  2) 在指令执行结束时调用。
- 异步中断：
  1) 由其它硬件生成。
  2) 相对于CPU的时钟来说，其发生时机是任意的。

中断由CPU内部定时器或I/O设备发出，比如用户敲击键盘就会产生中断。

异常就是由程序异常或其它异常条件发生时产生。前一种情况，内核发送信号给产生异常的进程。而后一种比如有Page faule或经由int(sysenter)指令来请求内核服务，这时内核会执行 *一系列步骤* 然后从 *异常中恢复* 。

* 中断信号的作用
中断信号提供了一种能力，它可以使得CPU转移(divert)出正常的指令执行流。中断信号到来时，CPU必
须停下它正在做的事情并切换到新的代码路径上。这通过以下两点做到：
1) 把当前的程序计数器（PC，program counter）存到内核态栈上（Kernel Mode stack）。
2) 放置与引起中断相关的服务例程到PC里。

这些文字可能会让我们联想到进程切换，不过中断处理和进程切换是完全不同的：
1) 执行中断/异常的代码可不是进程的代码。
2) 它是一种控制路径（control path），当中断发生时，代表进程执行。
3) 这种control path比起进程，它更加轻量，具有更少的上下文和处理时间。

* 中断、异常对比
英特尔文档对中断和异常做如下的归类：
1) 中断：
   1) 可屏蔽中断
      
      由I/O设备发出的中断都是可屏蔽的，可屏蔽中断有两种状态，屏蔽或非屏蔽，屏蔽了的中断会被CPU忽略。
   2) 不可屏蔽中断
      
      一些很关键的事件（比如硬件错误）是不能屏蔽的，这些中断一定会被CPU识别。
2) 异常：
   1) 处理器可检测异常
    
      在CPU执行指令的时候检测到的异常，其可分为三类。
      1) Faults
         
         这种类型的异常通常是可以被纠正的，eip寄存器存的就是当前引起Faults的指令。当相应的异常句柄执行完毕后，就会由eip指令处继续执行。比如page fault就有对应的异常句柄，就
         是此类的。 *这里eip存的是引起Faults的指令，等到异常句柄执行完毕返回时，也会从这条指令开始执行。*
      2) Traps

         *eip存放的是引起Traps指令的后一条指令。* Traps异常的情况不会再一次执行引起Traps的指令，这主要用于debugger，这里主要通知debugger一个特别的指令被执行了（比如breakpoint断点指令）。
      3) Aborts
      
   2) 程序异常
