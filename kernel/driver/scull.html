<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2021-03-09 Tue 22:47 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>一个简单的字符驱动程序</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../org-manual.css" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">一个简单的字符驱动程序</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org935a284">1. 背景知识</a>
<ul>
<li><a href="#org1f8c398">1.1. 主设备号和次设备号</a></li>
<li><a href="#orgce96fa6">1.2. 分配和释放设备编号</a></li>
<li><a href="#orgd76855d">1.3. 关键数据结构</a>
<ul>
<li><a href="#orgd55067b">1.3.1. file_operations</a></li>
<li><a href="#orgefb7fe6">1.3.2. file</a></li>
<li><a href="#orgadce966">1.3.3. inode</a></li>
</ul>
</li>
<li><a href="#org6ec845c">1.4. 字符设备注册</a>
<ul>
<li><a href="#orgf5af65c">1.4.1. scull驱动中的设备注册</a></li>
<li><a href="#org47a29c3">1.4.2. open和release方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org666acca">2. 代码实现</a></li>
</ul>
</div>
</div>
<p>
本文将详细介绍在Linux平台的一个简单字符驱动程序的编写。它操作的是一片内存，把内存当作设备，这样可以不依赖于具体的硬件设备, 就把这个简单字符驱动程序叫s_driver吧.
</p>

<div id="outline-container-org935a284" class="outline-2">
<h2 id="org935a284"><span class="section-number-2">1</span> 背景知识</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1f8c398" class="outline-3">
<h3 id="org1f8c398"><span class="section-number-3">1.1</span> 主设备号和次设备号</h3>
<div class="outline-text-3" id="text-1-1">
<p>
访问设备要通过文件系统中的设备文件。Linux把设备抽象成文件，访问设备也就是访问文件。这些文件都很特殊，通常位于/dev目录下，用ls -l可以看到字符设备第一列是c字母开头，而块设备是b开头，同时可以看到有两个数字由逗号隔开，如下图：
</p>

<div class="figure">
<p><img src="./img/ls-l.png" alt="ls-l.png" width="30%" height="30%" align="centering">
</p>
<p><span class="figure-number">Figure 1: </span>ls -l /dev的部分输出</p>
</div>

<p>
前一个数字就是所谓的主设备号, 后一个是次设备号. 所谓主设备号, 它标识了设备对应的驱动程序, 而次设备号用来确定具体的设备文件所指的设备. 不同的设备文件可由同一个驱动程序来进行管理, 比如图中的vcsu5和vcsu6由驱动程序7管理, 但次设备号69, 70区分了是哪个设备.
</p>

<p>
在内核内部, 用dev_t的类型来表示设备编号: 即包括主设备编号又包括次设备编号. 如下位于Linux内核中的代码:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">u32</span> <span style="color: #7CB8BB;">__kernel_dev_t</span>;
<span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">__kernel_dev_t</span>      <span style="color: #7CB8BB;">dev_t</span>;
</pre>
</div>
<p>
可以看到dev_t实际是一个32位的数. 其中的高12位用来表示主设备号, 而低20位用来表示次设备号. 当然这种情况可能不是未来一直都正确. 所以内核提供了操作dev_t类型的宏:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">MINORBITS</span>   20
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">MINORMASK</span>   ((1U &lt;&lt; MINORBITS) - 1)

<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">MAJOR</span>(<span style="color: #DFAF8F;">dev</span>)  ((<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span>) ((dev) &gt;&gt; MINORBITS))
<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">MINOR</span>(<span style="color: #DFAF8F;">dev</span>)  ((<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span>) ((dev) &amp; MINORMASK))
</pre>
</div>
<p>
MAJOR用于获得主设备号, 而MINOR用于获得次设备号. 可以稍微注意下这里的代码技巧, 首先定义了MINORBITS为20, dev右移20位丢弃低20位的数据即得高12位的major number, 为了获的minor number是先获得了MINORMASK, 即1先左移20位, 相当于1后跟20个0, 然后再减1, 这样20个0变成20个1, 再相与于dev即得低20位的minor number.
</p>

<p>
理解了这些宏, 下面的MKDEV要做的啥工作就很简单了:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">MKDEV</span>(<span style="color: #DFAF8F;">ma</span>,<span style="color: #DFAF8F;">mi</span>)    (((ma) &lt;&lt; MINORBITS) | (mi))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgce96fa6" class="outline-3">
<h3 id="orgce96fa6"><span class="section-number-3">1.2</span> 分配和释放设备编号</h3>
<div class="outline-text-3" id="text-1-2">
<p>
如前面的图, 设备都有编号, 自然我们的简单字符驱动程序s_driver也需要设备编号, 内核提供两个函数用来分配设备编号:
</p>
<ul class="org-ul">
<li>register_chrdev_region(dev_t first, unsigned int count, char *name)</li>
<li>alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)</li>
</ul>

<p>
两个函数的参数count和name的意义是一样的, count是所请求的连续设备编号的个数. name是和该设备编号范围相关的字符串名, 它会出现在/proc/devices中. 前一个函数中，first是要分配的设备编号范围的起始值。 而第二个函数用于动态的分配设备编号，其输出的设备编号会存在第一个参数dev中。
</p>

<p>
在使用完后，要予以释放：
</p>
<ul class="org-ul">
<li>void unregister_chrdev_region(dev_t first, unsigned count)</li>
</ul>

<p>
通常在模块清除函数中调用这个函数。
</p>

<p>
前述已讲到，操作设备其实还是是操作文件，只不过是一类特殊的设备文件。创建这些设备文件使用mknod命令，使用mknod命令创建设备文件时需要知道设备的主设备号作为参数，不过若选择alloc_chrdev_region方式来分配设备号，设备号是动态的，我们无法预先知道。这里有个方法是在加载了模块后，alloc_chrdev_region函数作为模块初始化的一部分，就注册好了设备号，在文件/proc/devices中可以看到，使用awk命令稍微处理下这个文本就可以得到major number了。如下取自s_driver_load.sh脚本中的部分代码所示：
</p>
<div class="org-src-container">
<pre class="src src-bash">insmod ./$<span style="color: #DFAF8F;">module</span>.ko $<span style="color: #DFAF8F;">*</span> || <span style="color: #F0DFAF; font-weight: bold;">exit</span> 1
<span style="color: #DFAF8F;">major</span>=$(<span style="color: #CC9393;">awk</span> <span style="color: #CC9393;">"\$2==\"$module\" {print \$1}"</span> /proc/devices)
mknod /dev/${<span style="color: #DFAF8F;">device</span>}0 c $<span style="color: #DFAF8F;">major</span> 0
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd76855d" class="outline-3">
<h3 id="orgd76855d"><span class="section-number-3">1.3</span> 关键数据结构</h3>
<div class="outline-text-3" id="text-1-3">
<p>
很多基本的驱动操作都涉及到三个重要的内核数据结构，分别是file_operations，file以及inode，下面依次来看看。
</p>
</div>

<div id="outline-container-orgd55067b" class="outline-4">
<h4 id="orgd55067b"><span class="section-number-4">1.3.1</span> file_operations</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
到目前为止，我们预留了设备号，但还没有将这些设备号与驱动操作联系起来，file_operations结构体正是设定这种连接。每一个打开的文件都有file结构体表示（后面会讲到），其内有一个file_operations类型的成员f_op指向了设备（驱动）的操作函数，这些操作也是对应相应的系统调用比如read，open等。可以把文件当作一个对象，而这些函数（file_operations）当作方法，这就是面向对象编程的术语了，其实内核中有很多这样的面向对象思想，以后还会看到。
</p>

<p>
下面可以先直观的看下file和file_operations结构体：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> {
    <span style="color: #F0DFAF; font-weight: bold;">union</span> {
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">llist_node</span>   <span style="color: #DFAF8F;">fu_llist</span>;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">rcu_head</span>     <span style="color: #DFAF8F;">fu_rcuhead</span>;
    } <span style="color: #DFAF8F;">f_u</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">path</span>     <span style="color: #DFAF8F;">f_path</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">inode</span>        *<span style="color: #DFAF8F;">f_inode</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">cached value</span><span style="color: #5F7F5F;"> */</span>
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span>    *<span style="color: #DFAF8F;">f_op</span>;
    ...
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> {
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">module</span> *<span style="color: #DFAF8F;">owner</span>;
    <span style="color: #7CB8BB;">loff_t</span> (*<span style="color: #93E0E3;">llseek</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #7CB8BB;">loff_t</span>, <span style="color: #7CB8BB;">int</span>);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">read</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">__user</span> *, <span style="color: #7CB8BB;">size_t</span>, <span style="color: #7CB8BB;">loff_t</span> *);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">write</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">__user</span> *, <span style="color: #7CB8BB;">size_t</span>, <span style="color: #7CB8BB;">loff_t</span> *);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">read_iter</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iov_iter</span> *);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">write_iter</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iov_iter</span> *);
    <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">iopoll</span>)(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *<span style="color: #DFAF8F;">kiocb</span>, <span style="color: #7CB8BB;">bool</span> <span style="color: #DFAF8F;">spin</span>);
    <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">iterate</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">dir_context</span> *);
    <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">iterate_shared</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">dir_context</span> *);
    <span style="color: #7CB8BB;">__poll_t</span> (*<span style="color: #93E0E3;">poll</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">poll_table_struct</span> *);
    ...
}
</pre>
</div>

<p>
通常，file_operations结构体或者指向file_operations结构体的指针叫做fops，每一个在结构体中的指针指向驱动里实现的具体的函数。而对于留NULL的指针，内核精确的行为有所不同。下面的列表介绍了可以对device调用的操作。
</p>

<ol class="org-ol">
<li><p>
struct module *owner
</p>

<p>
指向拥有file_operations的模块，这个成员用来防止模块正在操作时却被unload了。它一般被初始化为THIS_MODULE。
</p></li>
<li><p>
loff_t (*llseek) (struct file *, loff_t, int)
</p>

<p>
loff_t实际上是一个long long型。这个函数用来改变当前文件的读写位置，新的位置由一个返回的正数值表示，负值代表出错。如果这个函数是NULL，对llseek的调用将会以一种不可预知的方式修改file文件结构体的位置计数器（后文介绍）。
</p></li>
<li><p>
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)
</p>

<p>
ssize_t通常就是目标平台的整数类型。该函数用来从设备中读取内容，返回的正数值表示了实际读了多少字节，如果为NULL的话，read系统调用返回-EINVAL。
</p></li>

<li><p>
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)
</p>

<p>
给设备发送数据。如果为NULL，就返回-EINVAL给调用程序。返回值如果非负，代表成功写入的字节数。
</p></li>

<li><p>
__poll_t (*poll) (struct file *, struct poll_table_struct *)
</p>

<p>
这个函数是poll、epoll以及select的下层实现，这些函数的功能是：查询对于一个（或多个）文件描述符的读写是否会阻塞。该函数返回一个bit mask来表明是否一个非阻塞的读写操作是可能的（设备可以被立即读写，无需等待）。这也会提供给内核一些信息来决定是否应该将进程放入睡眠状态，直到I/O操作变得可能。如果这个函数是null，则是假定设备是可以无阻塞的读写的。
</p></li>

<li><p>
int (*mmap) (struct file *, struct vm_area_struct *)
</p>

<p>
mmap用来将设备的内存映射到进程的地址空间，如果这个函数是null，mmap就返回-ENODEV。
</p></li>

<li><p>
int (*open) (struct inode *, struct file *)
</p>

<p>
打开设备文件，如果这个函数是NULL，打开设备总是成功，但是驱动不会被通知。
</p></li>

<li><p>
int (*release) (struct inode *, struct file *)
</p>

<p>
当file结构体被释放时，该方法就会被调用，如同open，release也可是NULL。
</p></li>

<li><p>
int (*fsync) (struct file *, loff_t, loff_t, int datasync)
</p>

<p>
本函数是fsync系统调用的后端实现，用户调用fsync时，就会同步所有数据。如果本函数是NULL，调用它就会返回-EINVAL。
</p></li>

<li><p>
int (*fasync) (int, struct file *, int)
</p>

<p>
如果设备的FASYNC标志有所改变，本函数可以用来通知。
</p></li>

<li><p>
int (*lock) (struct file *, int, struct file_lock *)
</p>

<p>
用来实现文件锁，文件锁机制对于常规文件是不可或缺的，不过对于设备驱动来说几乎不会实现这个函数。
</p></li>
</ol>

<p>
s_driver只会实现其中几个重要的函数, 它的初始化如下:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> <span style="color: #DFAF8F;">s_fops</span> = {
        .owner =    THIS_MODULE,
        .llseek =   s_llseek,
        .read =     s_read,
        .write =    s_write,
        .unlocked_ioctl = s_ioctl,
        .open =     s_open,
        .release =  s_release,
};
</pre>
</div>

<p>
这个初始化方式在C里叫标签结构体初始化语法, 使得代码可读性较好, 这种方式允许重排成员的顺序,
在某些情况下, 将频繁访问的成员放在同一个硬件缓存行里会提高性能.
</p>
</div>
</div>


<div id="outline-container-orgefb7fe6" class="outline-4">
<h4 id="orgefb7fe6"><span class="section-number-4">1.3.2</span> file</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
file结构体定义在linux/fs.h中, 注意file结构体和用户程序中的FILE指针(在C库中实现)是根本不同的事物, file在内核空间中, FILE在用户空间中.
</p>

<p>
一个打开的文件都有一个与之关联的file结构体(设备驱动也不例外), 在调用open时就会创建这个结构体. 在内核上下文里, filep通常是一个指向file结构体的指针.
</p>

<p>
下面介绍一些其中的重要结构体:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> {
<span style="color: #7CB8BB;">fmode_t</span>         <span style="color: #DFAF8F;">f_mode</span>;
<span style="color: #7CB8BB;">loff_t</span>          <span style="color: #DFAF8F;">f_pos</span>;
<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span>        <span style="color: #DFAF8F;">f_flags</span>;
<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span>    *<span style="color: #DFAF8F;">f_op</span>;
<span style="color: #7CB8BB;">void</span>            *<span style="color: #DFAF8F;">private_data</span>;
};
</pre>
</div>
<p>
简单解释下这些成员的作用:
</p>

<ol class="org-ol">
<li><p>
f_mode:
</p>

<p>
这个域表明了文件是可读或可写的, 通过比特FMODE_READ或FMODE_WRITE来判断.
</p></li>

<li><p>
f_pos:
</p>

<p>
当前的文件读写位置, loff_t是一个64-bit的值. 驱动如果需要知道文件的当前位置, 可以读取这个成员, 但通常不应该修改它. 这个成员会依据read和write的最后一个成员来修改. llseek会直接修改这个成员.
</p></li>

<li><p>
f_flags:
</p>

<p>
这个成员表示了文件的标志, 比如O_RDONLY, O_NONBLOCK以及O_SYNC. 驱动应该检查O_NONBLOCK来检查是否是非阻塞操作请求, 而驱动很少使用其它标志了. 而read/write权限的检查应该f_mode而不是f_flags.
</p></li>

<li><p>
f_op:
</p>

<p>
与文件关联的函数操作指针. 作为open调用实现的一个部分, 内核会在其中分配file_operations结构体指针, 当需要发起操作时, 内核就会读取这个结构体. 同一个major number(比如1, 管理着/dev/null和/dev/zero)的不同设备, 因其minor number不同, 在open实现里就会根据这个minor
number来给f_op赋予不同的值, 这其实就是面向对象编程里的方法重载的概念.
</p></li>

<li><p>
private_data:
</p>

<p>
可以作为自己某种用途的空间, 当然也可以忽略. 如果不为空, 在release方法里, 在销毁file结构体之前,
要记得先释放private_data所指向的空间. 在我们的例子代码里常常会用这个成员来传递系统调用之间的状态信息.
</p></li>
</ol>
</div>
</div>
<div id="outline-container-orgadce966" class="outline-4">
<h4 id="orgadce966"><span class="section-number-4">1.3.3</span> inode</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
在内核内部使用的是inode结构体来表示文件，它与file结构体不同，file结构体用来表示一个打开的文件描述符。在一个文件上可以有许多打开的文件描述符，进而有多个file结构体与之对应，但是它们可能都对应一个inode结构体。
</p>

<p>
inode结构体包含许多信息，但是作为驱动作者，仅仅关心其中两个成员：
</p>

<ol class="org-ol">
<li><p>
dev_t i_rdev:
</p>

<p>
对于inode表示的是设备文件时，这个成员包含了实际的设备号码。
</p></li>

<li><p>
struct cdev *i_cdev:
</p>

<p>
当inode指向一个字符设备时，这个成员就是内核内部对于字符设备的结构体表示。
</p></li>
</ol>

<p>
为了提高程序的可移植性，内核开发者提供了两个宏用于从inode中获取major以及minor号码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">unsigned</span> <span style="color: #93E0E3;">iminor</span>(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">inode</span> *<span style="color: #DFAF8F;">inode</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">return</span> MINOR(inode-&gt;i_rdev);
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #7CB8BB;">unsigned</span> <span style="color: #93E0E3;">imajor</span>(<span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">inode</span> *<span style="color: #DFAF8F;">inode</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">return</span> MAJOR(inode-&gt;i_rdev);
}
</pre>
</div>

<p>
可以看到内部其实还是前文介绍过的MINOR和MAJOR宏。
</p>
</div>
</div>
</div>
<div id="outline-container-org6ec845c" class="outline-3">
<h3 id="org6ec845c"><span class="section-number-3">1.4</span> 字符设备注册</h3>
<div class="outline-text-3" id="text-1-4">
<p>
如前介绍过的，在内核内部使用cdev结构体来描述字符设备，在内核能够调用设备操作之前，必须要分配和注册这些结构体。在编写的代码里必须包含&lt;linux/cdev.h&gt;，这个头文件会定义相关的结构体和关联的辅助函数。
</p>

<p>
有两种方式可以用来初始化这些结构体，如果想在运行时动态的分配一个单独的cdev结构体，可以使用下面的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">cdev</span> *<span style="color: #DFAF8F;">my_cdev</span> = cdev_alloc();
my_cdev-&gt;ops = &amp;my_fops;
</pre>
</div>

<p>
不过某些时候，想要把cdev类型的结构体嵌入到自己定义的设备相关的结构体里，这也是scull驱动程
序所做的。在这种情况下，就需要使用如下代码来初始化了：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">cdev_init</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">cdev</span> *<span style="color: #DFAF8F;">cdev</span>, )
</pre>
</div>

<p>
无论采用哪种方式，cdev结构体都需要初始化。和file_operations结构体类似，struct cdev也有一个owner域需要被设置成THIS_MODULE。
</p>

<p>
cdev结构体设置好了之后，最后一步就是向内核宣告它的存在：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">cdev_add</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">cdev</span> *<span style="color: #DFAF8F;">dev</span>, <span style="color: #7CB8BB;">dev_t</span> <span style="color: #DFAF8F;">num</span>, <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">count</span>);
</pre>
</div>

<p>
这里dev就是cdev结构体了，num是这个设备会响应的第一个数字，count是关联到这个设备的号码个数。通常count是1，不过有时候对于一个特定的设备有多个设备号码是有意义的，比如，对于SCSI磁带驱动，通过分配给物理设备以多个minor number，可以允许用户空间去选择不同的操作模式。
</p>

<p>
使用cdev_add有几点需要注意，一是这个调用可能会失败，如果是返回负值，设备就没能加入到系统里。但大多数时候，它是返回成功的。不过只要cdev_add返回成功，设备在系统中就处于live状态，它与之关联的操作就可能会被调用。在完全准备好处理设备相关联的操作之前，cdev_add不应该被调用。
</p>

<p>
为了从系统中删除char字符设备：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">cdev_del</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">cdev</span> *<span style="color: #DFAF8F;">dev</span>);
</pre>
</div>

<p>
当然，cdev_del被调用了就不应该再访问cdev结构体了。
</p>
</div>
<div id="outline-container-orgf5af65c" class="outline-4">
<h4 id="orgf5af65c"><span class="section-number-4">1.4.1</span> scull驱动中的设备注册</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
scull驱动使用struct scull_dev来代表每个结构体。这个结构体如下定义：
</p>

<div class="figure">
<p><img src="./img/scull_dev.png" alt="scull_dev.png" width="30%" height="30%" align="centering">
</p>
<p><span class="figure-number">Figure 2: </span>scull_dev结构体</p>
</div>

<p>
后面遇到这个结构体里的成员时再详细介绍每个成员。现在注意下cdev成员，cdev充当内核和设备之间的接口。这个结构体必须被初始化并添加到系统中，scull的scull_setup_cdev函数完成这个处理：
</p>

<div class="figure">
<p><img src="./img/cdev-init.png" alt="cdev-init.png" width="30%" height="30%" align="centering">
</p>
<p><span class="figure-number">Figure 3: </span>cdev初始化</p>
</div>

<p>
注意这里是初始化dev里内嵌的cdev。
</p>
</div>
</div>

<div id="outline-container-org47a29c3" class="outline-4">
<h4 id="org47a29c3"><span class="section-number-4">1.4.2</span> open和release方法</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
现在可以看下在scull里使用的open和release方法。
</p>
</div>
<ol class="org-ol">
<li><a id="org0819a2f"></a>open方法<br>
<div class="outline-text-5" id="text-1-4-2-1">
<p>
驱动实现open方法一般是做一些准备的操作。在许多驱动里，open一般会执行下面这些任务：
</p>
<ul class="org-ul">
<li>检查设备相关的错误（比如设备未准备就绪或者是类似的硬件问题）。</li>
<li>如果设备是第一次打开，初始化它。</li>
<li>如果有必要，需要更新f_op指针。</li>
<li>分配和填充filp-&gt;private_data中的数据结构。</li>
</ul>

<p>
不过第一步当然是确认哪个设备被打开，回忆open方法的原型如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">open</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">inode</span> *<span style="color: #DFAF8F;">inode</span>, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *<span style="color: #DFAF8F;">filp</span>)
</pre>
</div>
<p>
inode参数里的i_cdev成员就包含了之前设置好的cdev结构体，但问题是我们并不想要cdev结构体，而是想要包含cdev结构体的scull_dev结构体。C语言提供offsetof来达到这个目的，不过在linux/kernel.h里已经定义好了一个container_of宏可供使用：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #93E0E3;">container_of</span>(pointer, container_type, container_field)
</pre>
</div>

<p>
这个宏的pointer参数指向一个container_field的类型，这个成员类型（container_field）存在于
container_type结构体中，并且返回一个指向包含结构体类型（container_type）的指针。
</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org666acca" class="outline-2">
<h2 id="org666acca"><span class="section-number-2">2</span> 代码实现</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2021-03-09 Tue 22:47</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
