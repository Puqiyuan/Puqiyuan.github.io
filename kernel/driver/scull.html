<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2020-12-15 Tue 21:50 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>一个简单的字符驱动程序</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy(pqy7172@gmail.com)">
<link rel="stylesheet" href="../../org-manual.css" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">一个简单的字符驱动程序</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org22df4d9">1. 背景知识</a>
<ul>
<li><a href="#org6429992">1.1. 主设备号和次设备号</a></li>
<li><a href="#org3c091e7">1.2. 分配和释放设备编号</a></li>
<li><a href="#org39920d3">1.3. 一些重要的数据结构</a>
<ul>
<li><a href="#org3c653fa">1.3.1. 文件操作数据结构（file_operations）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org445cb93">2. 代码实现</a></li>
</ul>
</div>
</div>
<p>
本文将详细介绍在Linux平台的一个简单字符驱动程序的编写。它操作的是一片内存，把内存当作设备，这样可以不依赖于具体的硬件设备, 就把这个简单字符驱动程序叫s_driver吧.
</p>

<div id="outline-container-org22df4d9" class="outline-2">
<h2 id="org22df4d9"><span class="section-number-2">1</span> 背景知识</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org6429992" class="outline-3">
<h3 id="org6429992"><span class="section-number-3">1.1</span> 主设备号和次设备号</h3>
<div class="outline-text-3" id="text-1-1">
<p>
访问设备要通过文件系统中的设备文件。Linux把设备抽象成文件，访问设备也就是访问文件。这些文件都很特殊，通常位于/dev目录下，用ls -l可以看到字符设备第一列是c字母开头，而块设备是b开头，同时可以看到有两个数字由逗号隔开，如下图：
</p>

<div class="figure">
<p><img src="./img/ls-l.png" alt="ls-l.png" width="30%" height="30%" align="centering">
</p>
<p><span class="figure-number">Figure 1: </span>ls -l /dev的部分输出</p>
</div>

<p>
前一个数字就是所谓的主设备号, 后一个是次设备号. 所谓主设备号, 它标识了设备对应的驱动程序, 而次设备号用来确定具体的设备文件所指的设备. 不同的设备文件可由同一个驱动程序来进行管理, 比如图中的vcsu5和vcsu6由驱动程序7管理, 但次设备号69, 70区分了是哪个设备.
</p>

<p>
在内核内部, 用dev_t的类型来表示设备编号: 即包括主设备编号又包括次设备编号. 如下位于linux内核中的代码:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">u32</span> <span style="color: #7CB8BB;">__kernel_dev_t</span>;
<span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #7CB8BB;">__kernel_dev_t</span>      <span style="color: #7CB8BB;">dev_t</span>;
</pre>
</div>
<p>
可以看到dev_t实际是一个32位的数. 其中的高12位用来表示主设备号, 而低20位用来表示次设备号. 当然这种情况可能不是未来一直都正确. 所以内核提供了操作dev_t类型的宏:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">MINORBITS</span>   20
<span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">MINORMASK</span>   ((1U &lt;&lt; MINORBITS) - 1)

<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">MAJOR</span>(<span style="color: #DFAF8F;">dev</span>)  ((<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span>) ((dev) &gt;&gt; MINORBITS))
<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">MINOR</span>(<span style="color: #DFAF8F;">dev</span>)  ((<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span>) ((dev) &amp; MINORMASK))
</pre>
</div>
<p>
MAJOR用于获得主设备号, 而MINOR用于获得次设备号. 可以稍微注意下这里的代码技巧, 首先定义了MINORBITS为20, dev右移20位丢弃低20位的数据即得高12位的major number, 为了获的minor number是先获得了MINORMASK, 即1先左移20位, 相当于1后跟20个0, 然后再减1, 这样20个0变成20个1, 再相与于dev即得低20位的minor number.
</p>

<p>
理解了这些宏, 下面的MKDEV要做的啥工作就很简单了:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">MKDEV</span>(<span style="color: #DFAF8F;">ma</span>,<span style="color: #DFAF8F;">mi</span>)    (((ma) &lt;&lt; MINORBITS) | (mi))
</pre>
</div>
</div>
</div>
<div id="outline-container-org3c091e7" class="outline-3">
<h3 id="org3c091e7"><span class="section-number-3">1.2</span> 分配和释放设备编号</h3>
<div class="outline-text-3" id="text-1-2">
<p>
如前面的图, 设备都有编号, 自然我们的简单字符驱动程序s_driver也需要设备编号, 内核提供两个函数用来分配设备编号:
</p>
<ul class="org-ul">
<li>register_chrdev_region(dev_t first, unsigned int count, char *name)</li>
<li>alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)</li>
</ul>

<p>
两个函数的参数count和name的意义是一样的, count是所请求的连续设备编号的个数. name是和该设备编号范围相关的字符串名, 它会出现在/proc/devices中. 前一个函数中，first是要分配的设备编号范围的起始值。 而第二个函数用于动态的分配设备编号，其输出的设备编号会存在第一个参数dev中。
</p>

<p>
在使用完后，要予以释放：
</p>
<ul class="org-ul">
<li>void unregister_chrdev_region(dev_t first, unsigned count)</li>
</ul>

<p>
通常在模块清除函数中调用这个函数。
</p>

<p>
前述已讲到，操作设备其实还是是操作文件，只不过是一类特殊的设备文件。创建这些设备文件使用mknod命令，使用mknod命令创建设备文件时需要知道设备的主设备号作为参数，不过若选择alloc_chrdev_region方式来分配设备号，设备号是动态的，我们无法预先知道。这里有个方法是在加载了模块后，alloc_chrdev_region函数作为模块初始化的一部分，就注册好了设备号，在文件/proc/devices中可以看到，使用awk命令稍微处理下这个文本就可以得到major number了。如下取自s_driver_load.sh脚本中的部分代码所示：
</p>
<div class="org-src-container">
<pre class="src src-bash">insmod ./$<span style="color: #DFAF8F;">module</span>.ko $<span style="color: #DFAF8F;">*</span> || <span style="color: #F0DFAF; font-weight: bold;">exit</span> 1
<span style="color: #DFAF8F;">major</span>=$(<span style="color: #CC9393;">awk</span> <span style="color: #CC9393;">"\$2==\"$module\" {print \$1}"</span> /proc/devices)
mknod /dev/${<span style="color: #DFAF8F;">device</span>}0 c $<span style="color: #DFAF8F;">major</span> 0
</pre>
</div>
</div>
</div>

<div id="outline-container-org39920d3" class="outline-3">
<h3 id="org39920d3"><span class="section-number-3">1.3</span> 一些重要的数据结构</h3>
<div class="outline-text-3" id="text-1-3">
<p>
很多基本的驱动操作都涉及到三个重要的内核数据结构，分别是file_operations，file以及inode，下面依次来看看。
</p>
</div>

<div id="outline-container-org3c653fa" class="outline-4">
<h4 id="org3c653fa"><span class="section-number-4">1.3.1</span> 文件操作数据结构（file_operations）</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
到目前为止，我们预留了设备号，但还没有将这些设备号与驱动操作联系起来，file_operations结构体正是设定这种连接。每一个打开的文件都有file结构体表示（后面会讲到），其内有一个file_operations类型的成员f_op指向了设备（驱动）的操作函数，这些操作也是对应相应的系统调用比如read，open等。可以把文件当作一个对象，而这些函数（file_operations）当作方法，这就是面向对象编程的术语了，其实内核中有很多这样的面向对象思想，以后还会看到。
</p>

<p>
下面可以先直观的看下file和file_operations结构体：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> {
    <span style="color: #F0DFAF; font-weight: bold;">union</span> {
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">llist_node</span>   <span style="color: #DFAF8F;">fu_llist</span>;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">rcu_head</span>     <span style="color: #DFAF8F;">fu_rcuhead</span>;
    } <span style="color: #DFAF8F;">f_u</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">path</span>     <span style="color: #DFAF8F;">f_path</span>;
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">inode</span>        *<span style="color: #DFAF8F;">f_inode</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">cached value</span><span style="color: #5F7F5F;"> */</span>
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span>    *<span style="color: #DFAF8F;">f_op</span>;
    ...
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> {
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">module</span> *<span style="color: #DFAF8F;">owner</span>;
    <span style="color: #7CB8BB;">loff_t</span> (*<span style="color: #93E0E3;">llseek</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #7CB8BB;">loff_t</span>, <span style="color: #7CB8BB;">int</span>);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">read</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">__user</span> *, <span style="color: #7CB8BB;">size_t</span>, <span style="color: #7CB8BB;">loff_t</span> *);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">write</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">__user</span> *, <span style="color: #7CB8BB;">size_t</span>, <span style="color: #7CB8BB;">loff_t</span> *);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">read_iter</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iov_iter</span> *);
    <span style="color: #7CB8BB;">ssize_t</span> (*<span style="color: #93E0E3;">write_iter</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iov_iter</span> *);
    <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">iopoll</span>)(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *<span style="color: #DFAF8F;">kiocb</span>, <span style="color: #7CB8BB;">bool</span> <span style="color: #DFAF8F;">spin</span>);
    <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">iterate</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">dir_context</span> *);
    <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">iterate_shared</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">dir_context</span> *);
    <span style="color: #7CB8BB;">__poll_t</span> (*<span style="color: #93E0E3;">poll</span>) (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">poll_table_struct</span> *);
    ...
}
</pre>
</div>

<p>
通常，file_operations结构体或者指向file_operations结构体的指针叫做fops，每一个在结构体中的指针指向驱动里实现的具体的函数。而对于留NULL的指针，内核精确的行为有所不同。下面的列表介绍了可以对device调用的操作。
</p>

<ol class="org-ol">
<li><p>
struct module *owner
</p>

<p>
指向拥有file_operations的模块，这个成员用来防止模块正在操作时却被unload了。它一般被初始化为THIS_MODULE。
</p></li>
<li><p>
loff_t (*llseek) (struct file *, loff_t, int)
</p>

<p>
loff_t实际上是一个long long型。这个函数用来改变当前文件的读写位置，新的位置由一个返回的正数值表示，负值代表出错。如果这个函数是NULL，对llseek的调用将会以一种不可预知的方式修改file文件结构体的位置计数器（后文介绍）。
</p></li>
<li><p>
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)
</p>

<p>
ssize_t通常就是目标平台的整数类型。该函数用来从设备中读取内容，返回的正数值表示了实际读了多少字节，如果为NULL的话，read系统调用返回-EINVAL。
</p></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org445cb93" class="outline-2">
<h2 id="org445cb93"><span class="section-number-2">2</span> 代码实现</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy(pqy7172@gmail.com)</p>
<p class="date">Created: 2020-12-15 Tue 21:50</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
