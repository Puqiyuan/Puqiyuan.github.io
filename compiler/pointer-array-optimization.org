#+TITLE: 编译器优化对数组和指针的性能影响
#+AUTHOR: Cauchy(pqy7172@gmail.com)
#+OPTIONS: ^:nil
#+EMAIL: pqy7172@gmail.com
#+HTML_HEAD: <link rel="stylesheet" href="../org-manual.css" type="text/css">

本文用实验说明数组和指针对于C程序的性能影响，总体结论是：数组和指针确有性能差别，不过编译优化的级别会对这种差别产生颠覆性的影响，并且不同的编译器、不同的优化级别表现效果不一样。

本文先简单介绍下这种数组替代指针的优化，然后通过编码一个具体的程序来验证，最后给出结论和工程实践的一般做法。


* 优化
尽量使用数组而不是指针。
* 应用
32位和64位程序都可以应用。
* 原理
访问数组的元素时，C语言允许数组操作符（[]）和指针两种形式。然而使用C指针使得编译的优化工作更难。如果没有细致的分析，编译器可以认为指针可以指向任何内存单元，比如*p和*q可以指向相同的内存位置，然而x[0]和x[2]却是代表不同的内存位置。这样使用指针容易引起 *别名* 问题：同一个内存位置可以以多种方式访问。通过减少 *别名* ，使得编译的优化工作更加容易进行。
* 验证
本节会提出一个程序，用来比较数组和指针操作的性能。xform_pointer和xform_array分别被函数t_xform_pointer和t_xform_array测试性能，xform_pointer和xform_array这两个函数的操作结果是一样的，函数原型除了函数名其它都一样。这两个函数输入一个一维浮点数组v，和一个二维浮点数组m，将v和m中的每一行按行序相乘然后求和存到一个一维数组res中。注意我们说一维、二维这些都是编译器（编程语言）级别的概念（抽象）。在物理内存里，内存地址永远是线性顺序排列。所以在xform_array中我们看到m首先被转换为matrix结构体，里面是二维数组，体现了逻辑的二维。而在xform_pointer中，却是以直接的一维逻辑取数据，假定内存是按行优先顺序存放，即每四个便一行。
** 编码
程序如下：
#+INCLUDE: "./pointer_array.c" src c
** 数据
下面给出各种数据。
*** gcc
指令数：
|    | array | pointer |
|----+-------+---------|
| O0 |   504 |     800 |
| O2 |   396 |     281 |
运行时间：
|    | array | pointer |
|----+-------+---------|
| O0 |  19.9 |    39.9 |
| O2 |   8.4 |     7.5 |
*** clang
指令数：
|    | array | pointer |
|----+-------+---------|
| O0 |   444 | 830     |
| O2 |   255 | *863*   |
运行时间：
|    | array | pointer |
|----+-------+---------|
| O0 |  19.9 |    39.9 |
| O2 |   5.7 |     7.9 |

* 实践
如前所述，数组和指针在O2优化时性能差距是很小的，然而对于clang这样的编译器来说数组优化提升可以有37%，这个数字是很大的。所以工程上的做法可以是编写指针和数组两套实现，然后在具体的编
译器下测试它们的性能。这里也可以说clang O2对于指针性能优化应该还可以做的更好，因为clang O2的array方式时间少很多，指令数上也可以看到clang对于指针别名问题可以说比较糟糕，优化后指令数
反而比O0更多。可以比较、理解clang O2的二进制和gcc O2的二进制有何区别，然后修改clang编译器相关的优化阶段。而gcc的O2对pointer的优化还稍微优一点，从这个方面说，gcc优秀。
