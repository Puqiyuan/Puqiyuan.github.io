<!DOCTYPE html>
<html lang="cn">
<head>
<!-- 2019-03-13 Wed 15:48 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>协程切换实现</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cauchy">
<link rel="stylesheet" href="https://cs3.swfu.edu.cn/~puqiyuan/org-manual.css" type="text/css">
<style>code {font-family:Monospace; font-size:90%; background-color: #eee} body {font-size:14pt}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">协程切换实现</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9dbf72c">1. 协程概念</a></li>
<li><a href="#orgef8f494">2. 架构介绍</a>
<ul>
<li><a href="#orgebcb678">2.1. X86</a></li>
<li><a href="#org75724a8">2.2. X86-64</a></li>
<li><a href="#orge925b35">2.3. ARM32</a></li>
<li><a href="#org5aba8b1">2.4. ARM64</a></li>
</ul>
</li>
<li><a href="#org6309bd7">3. 实现原理</a></li>
<li><a href="#org055624b">4. 编码实现</a>
<ul>
<li><a href="#orgc138ea7">4.1. X86</a>
<ul>
<li><a href="#org3e057e9">4.1.1. 准备</a></li>
<li><a href="#org7acc310">4.1.2. 保存任务环境</a></li>
<li><a href="#orgba580c9">4.1.3. 恢复任务环境</a></li>
<li><a href="#orgc871c3b">4.1.4. Call方式</a></li>
</ul>
</li>
<li><a href="#org7d2a4d1">4.2. X86-64</a></li>
<li><a href="#org3127aee">4.3. ARM32与ARM64</a></li>
</ul>
</li>
<li><a href="#org00a0254">5. 总结</a></li>
<li><a href="#orgc77518e">6. 后记</a></li>
</ul>
</div>
</div>
<p>
如果你在阅读本文时有任何疑惑，我多半怀疑那是我没有表达清楚，因为讲清楚切换这种细微的事并不是一件容易的事。我希望你投入到本文档的时间是值得的，能收获一些东西，所以如果有任何疑问请联系作者pqy7172@gmail.com。
</p>

<p>
在X86、X86-64平台上协程切换已得到实现的情况下，本文打算在ARM32、ARM64平台上实现同样的功能。在文尾还将介绍一种在已知机器指令的情况下如何获得栈大小的方法。
</p>

<div id="outline-container-org9dbf72c" class="outline-2">
<h2 id="org9dbf72c"><span class="section-number-2">1</span> 协程概念</h2>
<div class="outline-text-2" id="text-1">
<p>
进程是资源分配的基本单位，这些资源包括内存空间，文件表，外部设备等，而线程是CPU调度的基本单位。
</p>

<p>
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其它地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，
直接操作栈则基本没有内核切换的开销，所以上下文切换用时很少。注意本文在进行这些切换操作时并不涉及段的变化。
</p>

<p>
协程切换是用户空间的事，通过避免通常的切换陷入内核而带来的时间开销，这种切换较传统的上下文切换具有较高的效率。
</p>
</div>
</div>

<div id="outline-container-orgef8f494" class="outline-2">
<h2 id="orgef8f494"><span class="section-number-2">2</span> 架构介绍</h2>
<div class="outline-text-2" id="text-2">
<p>
本节将对X86、X86-64、ARM32、ARM64几种平台逐一进行介绍。当然完全的介绍一种体系结构超出了本文的范围，如果读者对此有兴趣，请参考相应官方手册。我仅关心之于我的目的所需要的体系结构的背景知识。这些背景知识包括寄存器介绍，调用惯例，常用指令。
</p>

<p>
寄存器包括通用寄存器和特殊寄存器，一般架构层面会规定出哪些寄存器是特殊的，另一方面，编译器也会说明一些通用寄存器来作为特别的目的。在操作这些特殊寄存器时要特别注意。
</p>

<p>
调用惯例作出了调用者（caller）和被调用者（callee）之间的一系列约定，这些约定包括参数如何传递，哪些寄存器被调用者可以覆盖，被调用者的局部变量应存于何处，结果应如何返回等。之于协程切换的目的，仅需关心参数如何传递并且只有一个参数的情况。
</p>

<p>
本文所涉及的四个平台常用指令都大同小异，下文具体到某个平台时再作详细介绍。
</p>

<p>
CPU架构经常的被分为复杂指令集（<a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer">CISC</a>）与精简指令集（<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC</a>）。常见的复杂指令集体系结构包括X86、
X86-64。常见的精简指令集包括ARM系列。二者在设计指令集时是完全相反的思路，CISC希望能在一个时钟周期内完成更多的事情，而RISC希望做更少的事情。这样CISC的指令集会较复杂，硬件电路设计会变得很复杂，但对于汇编程序编写较容易，而RISC具有相反的特点。在后文的<a href="#org5840383">编码实现</a>一节我们会看到这些不同的指令集设计哲学是如何影响到我们的汇编程序编写。网上有许多关于这二者设计思想有意思的讨论，可Google"cisc vs risc"。
</p>

<p>
以下针对体系结构的介绍仅涉及我们所需要的体系结构知识，其所述理论仅是相应体系结构的一个子集。
</p>
</div>
<div id="outline-container-orgebcb678" class="outline-3">
<h3 id="orgebcb678"><span class="section-number-3">2.1</span> X86</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<a id="org2df4dfb"></a>
本文所指X86具体为Intel 8086系列，这些CPU拥有32位字宽。
</p>
<ul class="org-ul">
<li>寄存器：包括八个通用寄存器eax、ebx、ecx、edx、esi、edi、ebp、esp。一个特殊寄存器eip用来指向当前所要运行的指令。通常编译器会赋予某些通用寄存器以特殊的用途，但体系结构层面并未如此强制要求，这一点下面的其它体系结构类似。这些由编译器指明的特殊寄存器的常见用途包括：
<ul class="org-ul">
<li>esp：栈指针，指示栈顶在何处。</li>
<li>ebp：指示栈基址。
<a id="org612f788"></a></li>
</ul></li>
<li>调用惯例：参数被压栈。</li>
<li>常用指令：
<ul class="org-ul">
<li>movl：在内存与寄存器或寄存器与寄存器之间移动数据。</li>
<li>pushl：将内存或某个寄存器的内容压栈。</li>
<li>ret：返回调用者。</li>
<li>leal：将操作数所指地址而非内容加载到寄存器或内存地址中。</li>
<li>subl：将两个操作数做减法。</li>
<li>jmp：无条件跳转。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org75724a8" class="outline-3">
<h3 id="org75724a8"><span class="section-number-3">2.2</span> X86-64</h3>
<div class="outline-text-3" id="text-2-2">
<p>
X86-64架构时X86架构的64位版，此架构具有64位机器字宽。
</p>
<ul class="org-ul">
<li>寄存器：包括16个通用寄存器rax、rbx、rcx、rdx、rsi、rdi、rbp、rsp、r8、r9、r10、r11、r12、r13、
r14、r15。一个特殊寄存器rip用来指向当前所要运行的指令。编译器赋予的特别用途的寄存器包括：
<ul class="org-ul">
<li>rsp：栈指针，指示栈顶在何处。</li>
<li>rbp：指示栈基址。</li>
</ul></li>
<li>调用惯例：第一个参数被传往rdi寄存器。</li>
<li>常用指令：
与X86类似，只是后缀l变为q，代表64位，而l代表32位。</li>
</ul>
</div>
</div>

<div id="outline-container-orge925b35" class="outline-3">
<h3 id="orge925b35"><span class="section-number-3">2.3</span> ARM32</h3>
<div class="outline-text-3" id="text-2-3">
<p>
此架构是ARM的32位版，ARM V7及以前的版本是为32位。
</p>
<ul class="org-ul">
<li>寄存器：包括r0-r10共计11个通用寄存器以及以下的特殊寄存器，括号内为其别名：
<ul class="org-ul">
<li>r11(fp)：栈基址寄存器。</li>
<li>r12：存储系统调用的号码。</li>
<li>r13(sp)：指示栈顶。</li>
<li>r14(lr)：存储返回地址。</li>
<li><p>
r15(pc)：程序计数器，指示当前运行的指令。下面是一个关于X86和ARM寄存器的对应表格。
</p>
<table border="2" rules="all">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">ARM</th>
<th scope="col" class="org-left">作用</th>
<th scope="col" class="org-left">x86</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">r0</td>
<td class="org-left">通用寄存器</td>
<td class="org-left">eax</td>
</tr>

<tr>
<td class="org-left">r1-r5</td>
<td class="org-left">通用寄存器</td>
<td class="org-left">ebx, ecx, edx, esi, edi</td>
</tr>

<tr>
<td class="org-left">r6-r10</td>
<td class="org-left">通用寄存器</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r11(fp)</td>
<td class="org-left">栈基址</td>
<td class="org-left">ebp</td>
</tr>

<tr>
<td class="org-left">r12</td>
<td class="org-left">系统调用</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r13(sp)</td>
<td class="org-left">栈指针</td>
<td class="org-left">esp</td>
</tr>

<tr>
<td class="org-left">r14(lr)</td>
<td class="org-left">链接寄存器</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">r15</td>
<td class="org-left">程序计数器</td>
<td class="org-left">eip</td>
</tr>
</tbody>
</table></li>
</ul></li>

<li>调用惯例：第一个参数会被送到r0寄存器。</li>
<li>常用指令：
<ul class="org-ul">
<li>str：将寄存器的值存到内存。</li>
<li>mov：在两个寄存器间移动值。</li>
<li>ldr：将内存中的某个值加载到寄存器。</li>
<li>push：将寄存器的值压栈。</li>
<li>add：对操作数执行加操作。</li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org5aba8b1" class="outline-3">
<h3 id="org5aba8b1"><span class="section-number-3">2.4</span> ARM64</h3>
<div class="outline-text-3" id="text-2-4">
<p>
ARM V8及以后的版本为64位。
</p>
<ul class="org-ul">
<li>寄存器：x0-x30共计31个寄存器。x31依使用环境决定是用作什么目的的寄存器，作为栈时写作sp。
特殊目的的寄存器包括：
<ul class="org-ul">
<li>x29：栈基址。</li>
<li>x30：链接寄存器，用于存放返回地址。</li>
</ul></li>

<li>调用惯例：第一个参数被传往x0寄存器。</li>
<li>常用指令：与ARM32类似，不同的是，ARM64下操作栈用stp和ldp指令并保证操作栈时16字节对齐，而不是ARM32的push与pop。返回调用调用者时用ret。</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org6309bd7" class="outline-2">
<h2 id="org6309bd7"><span class="section-number-2">3</span> 实现原理</h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="orgf1774bd"></a>
本节将概要介绍实现原理，而具体的代码实现细节留待下节。讨论实现时，协程（coroutine）、上下文(context)、任务(task)它们几者互为同义词。在讨论实现时，我更愿意用任务，而实现程序中多用上下文。
</p>

<p>
在CPU里定义任务环境：就是所有寄存器的内容。对于任务切换，我们需要保存当前任务环境，并恢复新任务的任务环境同时切换到新任务去运行。本实现分为两个方式：具有参数和不具有参数的切换。对于带参的，还需要按照调用惯例把参数传到相应的位置。
</p>

<p>
当前的任务环境存放到某个内存地址，而在另一个内存地址又存放着新任务的任务环境。当然，任务环境是一个较大的结构体，因为要存储和恢复的不只是一个寄存器，以上述两个内存地址作为基址，偏移一定的字节就得到各个寄存器的内容。
</p>

<p>
下面这个图来解释实现原理应该会更加清晰：
</p>

<pre class="example">
________________________________________________________
--------- current task          --------- resuming task |
|  r0   | store address         |  r0   | memory address|
---------                       ---------               |
|  r1   |                       |  r1   |               |
---------   \            /      ---------               |
|   .   |    \          /       |   .   |               |
|   .   |    1\        /2       |   .   |               |
               \      /                                 |
_____________________________________________memory_____|               
              ----------
              |switcher| the codes that you implement
              ----------
              /|\     |2
              1|     \|/
           ----------------
           |r0, r1, r2, r3|
           |r4, r5, r6, r7|
           |     ...      |
           ----------------
                 CPU
</pre>
</div>
</div>

<div id="outline-container-org055624b" class="outline-2">
<h2 id="org055624b"><span class="section-number-2">4</span> 编码实现</h2>
<div class="outline-text-2" id="text-4">
<p>
<a id="org938483b"></a>
此节将会详细讨论各个平台上的协程切换实现细节。尽管总体原理相似，但具体到实现层面依然有许多待解决的问题，接下来一一讨论。
</p>
</div>

<div id="outline-container-orgc138ea7" class="outline-3">
<h3 id="orgc138ea7"><span class="section-number-3">4.1</span> X86</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a id="org6d745fc"></a>
X86上的实现将会详细介绍，而其它架构的介绍会相对粗略。
</p>
</div>
<div id="outline-container-org3e057e9" class="outline-4">
<h4 id="org3e057e9"><span class="section-number-4">4.1.1</span> 准备</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
<a id="org0810e17"></a>
首先需要定义偏移，以定出偏移多少字节是哪个寄存器的内容。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_EAX</span> (0x00*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_EBX</span> (0x01*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_ECX</span> (0x02*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_EDX</span> (0x03*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_ESP</span> (0x04*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_ESI</span> (0x05*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_EDI</span> (0x06*COROUTINE_WORD_SIZE)
<span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #dbdb95;">COROUTINE_X86_REG_GEN_EBP</span> (0x07*COROUTINE_WORD_SIZE)
</pre>
</div>
<p>
其中，COROUTINE_WORD_SIZE是机器字宽，对于X86是4字节。
</p>

<p>
接下来需要将两个内存地址传递到栈上，以便协程切换时使用，这两个地址是用户给出。以下内联汇编完成了这个工作：
<a id="org46fadc1"></a>
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #00ede1; font-size: 110%; font-weight: bold;">COROUTINE_X86_JMP</span>(<span style="color: #dbdb95;">nowContextAddr</span>,<span style="color: #dbdb95;">gotoContextAddr</span>) <span style="color: #ffad29; font-weight: bold;">__asm__</span> \
  __volatile__(<span style="color: #e67128;">"subl $0x8,%%esp;movl %0,0x4(%%esp);movl %1,(%%esp);\</span>
<span style="color: #e67128;">call CoroutineX86Jmp"</span>::<span style="color: #e67128;">"r"</span>(gotoContextAddr),<span style="color: #e67128;">"r"</span>(nowContextAddr):<span style="color: #e67128;">"esp"</span>);
</pre>
</div>
<p>
关于内联汇编的知识可以参考<a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">这里</a>。请注意这段代码只是Jmp方式的切换，即新任务不带参运行。先是开栈，然后先把下一个要运行的任务地址入栈，接下来用来存储当前任务环境的内存地址入栈。
</p>


<p>
做好了准备工作就可以正式进行切换工作了。下面的两小节都是核心的切换代码部分，它包括保存当前任务环境和恢复新任务环境两大部分，注意这只是Jmp方式的切换，即 <code>CoroutineX86Jmp</code> 函数。最后会给出Call方式实现与Jmp的不同之处。
</p>
</div>
</div>

<div id="outline-container-org7acc310" class="outline-4">
<h4 id="org7acc310"><span class="section-number-4">4.1.2</span> 保存任务环境</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
第一步当然是保存当前的任务环境：
<a id="orgc32a717"></a>
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushl</span> <span style="color: #ffad29; font-weight: bold;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x2)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebx</span> ,COROUTINE_X86_REG_GEN_EBX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_ECX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%edx</span> ,COROUTINE_X86_REG_GEN_EDX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%esi</span> ,COROUTINE_X86_REG_GEN_ESI(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%edi</span> ,COROUTINE_X86_REG_GEN_EDI(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebp</span> ,COROUTINE_X86_REG_GEN_EBP(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">leal</span> (COROUTINE_WORD_SIZE*0x4)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_ESP(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x1)(<span style="color: #dbdb95;">%esp</span>) ,<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_EIP(<span style="color: #dbdb95;">%eax</span>)  
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (<span style="color: #dbdb95;">%esp</span>) ,<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_EAX(<span style="color: #dbdb95;">%eax</span>)
</pre>
</div>

<p>
下面一一分析这段代码以及其中隐藏的陷阱。
</p>

<p>
由于要用eax寄存器，所以首先将eax进行了压栈。
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushl</span> <span style="color: #ffad29; font-weight: bold;">%eax</span>
</pre>
</div>
<p>
这一步完成之后，栈的结构如下图：
<a id="org37d8080"></a>
</p>
<pre class="example">
16------------------- high address
  | gotoContextAddr |
12-------------------
  | nowContextAddr  | stack     |
8 ------------------- growth    |
  | return address  | direction |
4 -------------------           |
  |       rax       |          \./
0 ------------------- sp
  |        .        |
  |        .        | low address
</pre>
<p>
其中， <code>gotoContextAddr</code> 和 <code>nowContextAddr</code> 是在<a href="#org0810e17">准备</a>一节压入栈的，而在那一节调用
<code>CoroutineX86Jmp</code> 函数时，会将 <code>return address</code>
压入栈。接下来取到用来存储当前任务环境的内存地址到eax：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x2)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%eax</span>
</pre>
</div>

<p>
注意 <code>COROUTINE_WORD_SIZE*0x2</code> 为8，正好是用来存储当前任务环境的内存地址在栈中的偏移。
</p>

<p>
接下来就是存储ebx、ecx、edx、esi、edi、ebp寄存器的内容，以先前定义好的偏移来存储。
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebx</span> ,COROUTINE_X86_REG_GEN_EBX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_ECX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%edx</span> ,COROUTINE_X86_REG_GEN_EDX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%esi</span> ,COROUTINE_X86_REG_GEN_ESI(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%edi</span> ,COROUTINE_X86_REG_GEN_EDI(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebp</span> ,COROUTINE_X86_REG_GEN_EBP(<span style="color: #dbdb95;">%eax</span>)
</pre>
</div>
<p>
直到要存储esp时，发现它的存储与前述几个寄存器都不一样，不再那么简单直接。这就引出存储当前任务环境时极其重要的一点意识：
<a id="org4409f53"></a>
<b>进行存储的过程中，一定不能破坏进入到切换代码前(也就是我们自己写的汇编代码)的任务环境。</b>
这一点相当重要，如果在编写切换代码过程中稍微不记住这点，就可能会引起难以察觉令人抓狂的bug。
我们来看这两行代码：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">leal</span> (COROUTINE_WORD_SIZE*0x4)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_ESP(<span style="color: #dbdb95;">%eax</span>)
</pre>
</div>
<p>
<a href="#org2df4dfb">前文</a>介绍过leal指令的作用，它并不是将栈偏移 <code>COROUTINE_WORD_SIZE*0x4</code>
为16的地址的内容给ecx寄存器，而是将这个地址给ecx。接着又将这个地址存到当前任务存储地址起始偏移 <code>COROUTINE_X86_REG_GEN_ESP</code> 也就是说 <code>sp+16</code> 作为了当前任务环境的栈指针，这是合理的，
因为<a href="#org37d8080">图中</a>栈上的元素都是我们切换器代码压入的，这些压入动作影响了原来当前任务的栈指针，回退16
字节才是当前任务环境的栈指针。
</p>

<p>
当前任务环境的eip存储也不那么直接简单，这涉及有关切换的几个任务之间的关系分析。下图应该能清晰反映调用者（caller）、切换代码（switcher）、存储当前任务环境的内存地址(current task)三者之间的关系。
</p>

<pre class="example">
   caller                              stack                                      current task
-------------  1:put return        -------------                                    --------
|statement 1|  return address    \ |    ...    |                                    |  r0  |
|   call----|--------------------- ------------- return address ---------- 3:store \--------
|statement 3|         |          / |statement 3|----------------|switcher|----------|  eip |
|    ...    |         |            -------------                ---------- return  /|   .  |
                      |            |    ...    |                   /|\     address  |   .  |
                      |                                             |               -memory-
                      |_____________________________________________|              context of
                                     2:call switcher                                 caller
</pre>
<p>
X86架构在调用函数（ <code>CoroutineX86Jmp</code> ）时会自动将返回地址压栈，图中步骤1，在调用
<code>CoroutineX86Jmp</code> 后， <code>CoroutineX86Jmp</code> 也将作为一个任务，但我们要保存的是调用者（caller）
的返回地址。
</p>

<p>
所以接下来保存eip的代码就不难理解了：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x1)(<span style="color: #dbdb95;">%esp</span>) ,<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_EIP(<span style="color: #dbdb95;">%eax</span>)  
</pre>
</div>
<p>
<code>COROUTINE_WORD_SIZE*0x1</code> 为4，即是返回地址在栈上的偏移。
最后一步保存eax寄存器的值，eax在栈顶，一进来 <code>CoroutineX86Jmp</code> 函数eax就被压栈保存了。
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (<span style="color: #dbdb95;">%esp</span>) ,<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_EAX(<span style="color: #dbdb95;">%eax</span>)
</pre>
</div>

<p>
完成了当前任务环境的保存，接下来应该恢复要运行任务的任务环境。
</p>
</div>
</div>
<div id="outline-container-orgba580c9" class="outline-4">
<h4 id="orgba580c9"><span class="section-number-4">4.1.3</span> 恢复任务环境</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
这段代码是 <code>CoroutineX86Jmp</code> 的第二部分，代码如下：
<a id="orgcf57b08"></a>
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x3)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%eax</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EBX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebx</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ECX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EDX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%edx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ESI(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%esi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EDI(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%edi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EBP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebp</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ESP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%esp</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EIP(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EAX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ret</span>
</pre>
</div>
<p>
下面逐一分析这段代码。
</p>

<p>
根据实现<a href="#orgf1774bd">实现原理</a>，要恢复运行任务的环境存放于某个内存地址，在<a href="#org0810e17">准备</a>一节我们又把它移到了栈上。
所以首先是取出这个任务的地址：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x3)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%eax</span> 
</pre>
</div>
<p>
接下来就是一串的恢复寄存器：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EBX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebx</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ECX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EDX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%edx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ESI(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%esi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EDI(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%edi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EBP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebp</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ESP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%esp</span> 
</pre>
</div>

<p>
在恢复eip时，我们又遭遇了不那么简单直接的操作，这涉及X86的程序控制转交机制。最后一句指令是
ret，这句指令具体所作是将控制流转移到栈顶所存的地址，所以先就将要恢复任务的eip压到了栈上，
现在来看下面的代码就不难理解了：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EIP(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EAX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ret</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc871c3b" class="outline-4">
<h4 id="orgc871c3b"><span class="section-number-4">4.1.4</span> Call方式</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
Call方式多了一个参数，导致了其栈结构与Jmp方式不一样，其它类似于Jmp方式的实现，根据X86的<a href="#org612f788">调用惯例</a>，我们要保证在切换到新任务运行前参数被放置于正确的位置－即栈上。
</p>

<p>
以下代码是调用 <code>CoroutineX86Call</code> 的代码：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #00ede1; font-size: 110%; font-weight: bold;">COROUTINE_X86_CALL</span>(<span style="color: #dbdb95;">nowContextAddr</span>,<span style="color: #dbdb95;">gotoContextAddr</span>,<span style="color: #dbdb95;">param</span>) __asm__ \
  <span style="color: #ffad29; font-weight: bold;">__volatile__</span>(<span style="color: #e67128;">"subl $0x0c,%%esp;movl %0,0x8(%%esp);movl %1,0x4(%%esp);movl %2,(%%esp);\</span>
<span style="color: #e67128;">call CoroutineX86Call"</span>::<span style="color: #e67128;">"r"</span>(param),<span style="color: #e67128;">"r"</span>(gotoContextAddr),<span style="color: #e67128;">"r"</span>(nowContextAddr):<span style="color: #e67128;">"esp"</span>)<span style="color: #fa8072;">;</span>
</pre>
</div>
<p>
可以看到，其与Jmp方式的<a href="#org46fadc1">调用</a>并无本质区别，只是多压了一个参数入栈并且相应的调整了开栈的大小。
</p>

<p>
下面也是保存当前任务环境：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushl</span> <span style="color: #ffad29; font-weight: bold;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x2)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebx</span> ,COROUTINE_X86_REG_GEN_EBX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_ECX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%edx</span> ,COROUTINE_X86_REG_GEN_EDX(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%esi</span> ,COROUTINE_X86_REG_GEN_ESI(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%edi</span> ,COROUTINE_X86_REG_GEN_EDI(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebp</span> ,COROUTINE_X86_REG_GEN_EBP(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">leal</span> (COROUTINE_WORD_SIZE*0x5)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_ESP(<span style="color: #dbdb95;">%eax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x1)(<span style="color: #dbdb95;">%esp</span>) ,<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_EIP(<span style="color: #dbdb95;">%eax</span>)  
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (<span style="color: #dbdb95;">%esp</span>) ,<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ecx</span> ,COROUTINE_X86_REG_GEN_EAX(<span style="color: #dbdb95;">%eax</span>)
</pre>
</div>
<p>
在第一句 <code>pushl %eax</code> 后其栈结构与<a href="#org37d8080">Jmp方式</a>的栈结构有所区别：
</p>
<pre class="example">
20------------------- high address
  |      param      |
16------------------- 
  | gotoContextAddr |
12-------------------           |
  | nowContextAddr  | stack     |
8 ------------------- growth    |
  | return address  | direction |
4 -------------------           |
  |       rax       |          \./
0 ------------------- sp
  |        .        |
  |        .        | low address
</pre>
<p>
所以保存当前任务环境的代码就没什么新鲜的了。与<a href="#orgc32a717">Jmp方式</a>的不同就是保存栈顶时偏移为20，这是自然的，因为多了一个参数压栈。
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">leal</span> (COROUTINE_WORD_SIZE*0x5)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%ecx</span>
</pre>
</div>
<p>
在恢复时，大体也与<a href="#orgcf57b08">Jmp方式</a>类似：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x3)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%eax</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x4)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%ebx</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ECX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ecx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EDX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%edx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ESI(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%esi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EDI(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%edi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EBP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebp</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_ESP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%esp</span>  
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">subl</span> <span style="color: #ffad29; font-weight: bold;">$</span>(COROUTINE_WORD_SIZE*0x2),<span style="color: #dbdb95;">%esp</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebx</span>,(COROUTINE_WORD_SIZE*0x1)(<span style="color: #dbdb95;">%esp</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EIP(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebx</span>,(<span style="color: #dbdb95;">%esp</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EBX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%ebx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_X86_REG_GEN_EAX(<span style="color: #dbdb95;">%eax</span>),<span style="color: #dbdb95;">%eax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">jmp</span>  *(<span style="color: #dbdb95;">%esp</span>)
</pre>
</div>
<p>
需要关注的不同就是其参数的确传到了栈顶：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> (COROUTINE_WORD_SIZE*0x4)(<span style="color: #dbdb95;">%esp</span>),<span style="color: #dbdb95;">%ebx</span> 
</pre>
</div>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movl</span> <span style="color: #ffad29; font-weight: bold;">%ebx</span>,(<span style="color: #dbdb95;">%esp</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7d2a4d1" class="outline-3">
<h3 id="org7d2a4d1"><span class="section-number-3">4.2</span> X86-64</h3>
<div class="outline-text-3" id="text-4-2">
<p>
在<a href="#orgebcb678">X86</a>中详细讨论了实现原理，所以在X86-64下的实现只会概述其与X86实现的不同，本小节尾会列出本架构Jmp方式实现的代码，为避免冗余，其它代码不予列出。
</p>

<p>
Jmp与Call的实现均与X86下的实现类似，只是指令后缀为q代表64比特，并且多保存或恢复了几个寄存器。
</p>

<p>
调用：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffad29; font-weight: bold;">static</span> <span style="color: #ffad29; font-weight: bold;">__attribute__</span>((optimize(<span style="color: #e67128;">"-O0"</span>))) <span style="color: #34cae2; font-weight: bold;">void</span> \
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">COROUTINE_IA64_JMP</span>(<span style="color: #34cae2; font-weight: bold;">void</span> * <span style="color: #dbdb95;">nowContextAddr</span>,<span style="color: #34cae2; font-weight: bold;">void</span> * <span style="color: #dbdb95;">gotoContextAddr</span>) \
{\
  <span style="color: #ffad29; font-weight: bold;">__asm__</span> \
  __volatile__(<span style="color: #e67128;">"subq $0x10,%%rsp;movq %0,0x08(%%rsp);movq %1,(%%rsp);\</span>
<span style="color: #e67128;">  "</span>::<span style="color: #e67128;">"r"</span>(gotoContextAddr),<span style="color: #e67128;">"r"</span>(nowContextAddr):<span style="color: #e67128;">"rsp"</span>);\
  CoroutineIA64Jmp();\
  <span style="color: #ffad29; font-weight: bold;">__asm__</span> __volatile__(<span style="color: #e67128;">""</span>:::<span style="color: #e67128;">"rsp"</span>);\
}
</pre>
</div>
<p>
保存当前任务环境：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushq</span> <span style="color: #ffad29; font-weight: bold;">%rax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> (COROUTINE_WORD_SIZE*0x2)(<span style="color: #dbdb95;">%rsp</span>),<span style="color: #dbdb95;">%rax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rbx</span> ,COROUTINE_IA64_REG_GEN_RBX(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rcx</span> ,COROUTINE_IA64_REG_GEN_RCX(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rdx</span> ,COROUTINE_IA64_REG_GEN_RDX(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rsi</span> ,COROUTINE_IA64_REG_GEN_RSI(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rdi</span> ,COROUTINE_IA64_REG_GEN_RDI(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rbp</span> ,COROUTINE_IA64_REG_GEN_RBP(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r8</span> ,COROUTINE_IA64_REG_GEN_R8(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r9</span> ,COROUTINE_IA64_REG_GEN_R9(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r10</span> ,COROUTINE_IA64_REG_GEN_R10(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r11</span> ,COROUTINE_IA64_REG_GEN_R11(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r12</span> ,COROUTINE_IA64_REG_GEN_R12(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r13</span> ,COROUTINE_IA64_REG_GEN_R13(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r14</span> ,COROUTINE_IA64_REG_GEN_R14(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%r15</span> ,COROUTINE_IA64_REG_GEN_R15(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">lea</span> (COROUTINE_WORD_SIZE*0x4)(<span style="color: #dbdb95;">%rsp</span>),<span style="color: #dbdb95;">%rcx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rcx</span> ,COROUTINE_IA64_REG_GEN_RSP(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> (COROUTINE_WORD_SIZE*0x1)(<span style="color: #dbdb95;">%rsp</span>) ,<span style="color: #dbdb95;">%rcx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rcx</span> ,COROUTINE_IA64_REG_GEN_RIP(<span style="color: #dbdb95;">%rax</span>)  
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> (<span style="color: #dbdb95;">%rsp</span>) ,<span style="color: #dbdb95;">%rcx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">%rcx</span> ,COROUTINE_IA64_REG_GEN_RAX(<span style="color: #dbdb95;">%rax</span>)
</pre>
</div>
<p>
恢复下一个任务环境：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> (COROUTINE_WORD_SIZE*0x3)(<span style="color: #dbdb95;">%rsp</span>),<span style="color: #dbdb95;">%rax</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RBX(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rbx</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RCX(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rcx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RDX(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rdx</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RSI(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rsi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RDI(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rdi</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RBP(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rbp</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RSP(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rsp</span>  
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R8(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r8</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R9(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r9</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R10(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r10</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R11(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r11</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R12(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r12</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R13(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r13</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R14(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r14</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_R15(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%r15</span> 
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">pushq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RIP(<span style="color: #dbdb95;">%rax</span>)
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">movq</span> <span style="color: #ffad29; font-weight: bold;">COROUTINE</span>_IA64_REG_GEN_RAX(<span style="color: #dbdb95;">%rax</span>),<span style="color: #dbdb95;">%rax</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">retq</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3127aee" class="outline-3">
<h3 id="org3127aee"><span class="section-number-3">4.3</span> ARM32与ARM64</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<a id="org5840383"></a>
明白了X86系列的实现，ARM上的实现应该也能简单起来。需要注意的是X86实现下的指令如何与ARM架构下的指令对应起来。ARM32的切换是通过改变r15寄存器做到的，而ARM64是通过br或ret指令。实现Call
带参方式时，参数要保证传到对应的地方，ARM32是r0寄存器而ARM64是x0寄存器。在X86下很多指令都可以直接操作内存，操作内存在指令层面可以算是一个复杂的事情，这在X86上很多指令都可以做到，
这是因为X86基于复杂指令集，而ARM下仅有两条指令可以操作内存，ldr，str，在X86上可以直接对内存的值进行计算，但是在ARM下，必须用ldr将内存的值加载到某个寄存器中才能进行运算，这给编写
ARM汇编程序带来了不少麻烦。另外，在ARM64下我们不能像ARM32下那样直接操作栈指针，也要通过中间寄存器来操作。另外，ARM64在操作栈指针时必须保证16字节对齐。由于这些体系结构的特点以及前述提到的<a href="#org4409f53">重要意识</a>，给ARM汇编实现带来不小的麻烦。
</p>

<p>
下面仅列出ARM64的Call方式实现的代码，读者可以与前述X86实现作对比。
</p>

<p>
调用：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6495ed; font-style: italic;">#define</span> <span style="color: #00ede1; font-size: 110%; font-weight: bold;">COROUTINE_ARM64_CALL</span>(<span style="color: #dbdb95;">nowContextAddr</span>, <span style="color: #dbdb95;">gotoContextAddr</span>, <span style="color: #dbdb95;">param</span>) <span style="color: #ffad29; font-weight: bold;">__asm__</span> \
        __volatile__(<span style="color: #e67128;">"mov x0, %0; mov x1, %1; mov x2, %2;\</span>
<span style="color: #e67128;">bl CNEOSARM64CoroutineCall"</span>::<span style="color: #e67128;">"r"</span>(param), <span style="color: #e67128;">"r"</span>(gotoContextAddr), <span style="color: #e67128;">"r"</span>(nowContextAddr): <span style="color: #e67128;">"x0"</span>, <span style="color: #e67128;">"x1"</span>, <span style="color: #e67128;">"x2"</span>);
</pre>
</div>

<p>
切换：
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">All immediate calculations can be obtained</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">from pub_coroutine.h file</span>

<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">until now, the memory address used to store</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">the current task(context) state is placed</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">in the x2 register.</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">but the address of the task(context) to be run</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">is placed in the x1 register.</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">and the param is placed to x0 register.</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">--------------</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">r0: param    |</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">r1: goto     |</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">r2: current  |</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">--------------</span>


<span style="color: #00ede1; font-size: 110%; font-weight: bold;">stp</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, x1, [sp, #-16]!<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">store param(x0) to stack</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">mov</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, x2
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">store now context's data</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x2</span>, [x0, #16]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x3</span>, [x0, #24]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x4</span>, [x0, #32]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x5</span>, [x0, #40]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x6</span>, [x0, #48]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x7</span>, [x0, #56]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x8</span>, [x0, #64]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x9</span>, [x0, #72]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x10</span>, [x0, #80]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x11</span>, [x0, #88]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x12</span>, [x0, #96]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x13</span>, [x0, #104]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x14</span>, [x0, #112]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x15</span>, [x0, #120]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x16</span>, [x0, #128]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x17</span>, [x0, #136]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x18</span>, [x0, #144]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x19</span>, [x0, #152]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x20</span>, [x0, #160]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x21</span>, [x0, #168]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x22</span>, [x0, #176]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x23</span>, [x0, #184]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x24</span>, [x0, #192]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x25</span>, [x0, #200]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x26</span>, [x0, #208]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x27</span>, [x0, #216]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x28</span>, [x0, #224]

<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">we can't store the sp register directly</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">stp</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, x30, [sp, #-16]!
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">add</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, sp, #32<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">IT'S 32 OFFSET FOR THE STACK BEFORE ENTER THIS FUNCTION</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">str x31(sp)</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, [x0, #248]

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldp</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, x30, [sp], #16
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, [x0, #232]

<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">store return address</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x30</span>, [x0, #240]

<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">store x0, x1</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldp</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, x1, [sp], #16
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, [x2, #0]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">str</span> <span style="color: #ffad29; font-weight: bold;">x1</span>, [x2, #8]<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">note that this time we use x2</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">as base, because x2 stores also the memory</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">address where to store current task(context)</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">and x0 is corrupted by ldp</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">stp</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, x1, [sp, #-16]!  <span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">store param to stack</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">mov</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, x1 <span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">get the task(coroutine) struct address</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">of next running</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x2</span>, [x0, #16]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x3</span>, [x0, #24]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x4</span>, [x0, #32]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x5</span>, [x0, #40]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x6</span>, [x0, #48]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x7</span>, [x0, #56]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x8</span>, [x0, #64]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x9</span>, [x0, #72]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x10</span>, [x0, #80]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x11</span>, [x0, #88]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x12</span>, [x0, #96]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x13</span>, [x0, #104]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x14</span>, [x0, #112]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x15</span>, [x0, #120]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x16</span>, [x0, #128]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x17</span>, [x0, #136]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x18</span>, [x0, #144]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x19</span>, [x0, #152]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x20</span>, [x0, #160]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x21</span>, [x0, #168]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x22</span>, [x0, #176]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x23</span>, [x0, #184]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x24</span>, [x0, #192]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x25</span>, [x0, #200]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x26</span>, [x0, #208]

<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">get the return address to run</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x30</span>, [x0, #240]<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">resume x30</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldp</span> <span style="color: #ffad29; font-weight: bold;">x27</span>, x28, [sp], #16<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">put the param to x27</span>
<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">resume sp(x31) of task(context) that will be run</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, [x0, #248]
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">mov</span> <span style="color: #ffad29; font-weight: bold;">sp</span>, x29<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">NOW THE SATCK CHANGED, resume x31</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x29</span>, [x0, #232]<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">resume x29</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">stp</span> <span style="color: #ffad29; font-weight: bold;">x27</span>, x28, [sp, #-16]!<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">PUT THE PARAM TO NEW STACK</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x27</span>, [x0, #216]<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">resume x27</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">mov</span> <span style="color: #ffad29; font-weight: bold;">x28</span>, x0

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldp</span> <span style="color: #ffad29; font-weight: bold;">x0</span>, x1, [sp], #16<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">put the param to x0</span>
<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x1</span>, [x28, #8]<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">resume x1</span>

<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">ldr x0, [x28, #0]</span>

<span style="color: #00ede1; font-size: 110%; font-weight: bold;">ldr</span> <span style="color: #ffad29; font-weight: bold;">x28</span>, [x28, #224]<span style="color: #fa8072;">//</span><span style="color: #74af68; font-style: italic;">resume x28</span>
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org00a0254" class="outline-2">
<h2 id="org00a0254"><span class="section-number-2">5</span> 总结</h2>
<div class="outline-text-2" id="text-5">
<p>
协程切换在概念上不算一个复杂的事。技术上的很多概念都来源于生活，并不稀奇。犹如交换两瓶醋和酱油，我们不能直接倒入另一瓶，否则会污染另一瓶的东西。在瓶子不够用的情况下，如何保证腾出一个瓶子且不污染瓶子里的东西。不论怎么交换移动，一直都要谨慎：醋和酱油不能混起来也不能洒出来。
这些都是再平常不过的生活经验。
</p>

<p>
技术（理论）是灰色的，而生活之树常青。
</p>
</div>
</div>

<div id="outline-container-orgc77518e" class="outline-2">
<h2 id="orgc77518e"><span class="section-number-2">6</span> 后记</h2>
<div class="outline-text-2" id="text-6">
<p>
在这篇后记里，我想介绍一种已知机器指令的情况下如何获得栈大小的方法，这种方法主要是针对
ARM64平台。
</p>

<p>
函数在调用时如果需要开栈，那么一定会在函数代码段的开头几个指令进行开栈操作，我们已知的是像这样编译出来的机器指令：0xff, 0x6f, 0x5f, 0xd1, 0xff, 0x03, 0x2f, 0xd1。这些指令蕴含了栈的大小，现在要做的是如何提取出栈的大小，栈大小在指令中是以立即数的形式出现，比如 <code>sub sp sp
　#16</code>
中的16就是立即数也是栈的大小。
</p>

<p>
ARM64函数要开栈时，使用sub指令对栈指针进行减法操作，为了提取出栈大小我们需要知道sub指令的两个操作数为sp寄存器时的详细编码结构。ARM指令都是4字节长，不论32位还是64位，这也是RISC指令集的一个特点。固定长度的指令导致立即数的编码只能得到有限的空间，ARM64给予立即数12个比特位的空间。这样只能编码0-4095的立即数，但是ARM可开的栈空间可以远大于4095字节，这是因为ARM额外提供了两个比特位（具体到开栈，低位有效），当它有效时对12个比特位所代表的数字扩大2**12倍。
下图是改编自<a href="https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile">ARM64官方手册</a>C4-234页的一张图，此图完全决定了我们的程序应该如何编写：
</p>

<pre class="example">
｜　　　　byte 3 　　　　　｜         byte 2           |       byte 1         |    byte 0      |
31 30 29 28 27 26 25 24 |23   22| 21 20 19 18 17 16 15 14 13 12 11 10| 9 8 7 6 5| 4 3 2 1 0|
sf op S  1  0  0  0  1  | shift |              imm12                 |    Rn    |   Rd     |
</pre>

<p>
对于开栈指令，0-9比特位都为1。sf，op也为1，而S为0。这些比特位的具体意义也可以参照ARM64官方手册，之于我们的目的——计算栈大小，只需知道0-9比特位都为1，sf，op也为1，S为0确定了这是一条开栈指令，然后要判断该指令中的立即数是否需要移位，即扩大2**12倍。这是由23与22位比特决定。
然后就是取出10-21比特的立即数进行运算取得栈大小。
</p>

<p>
实现代码如下图：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span> <span style="color: #00ede1; font-size: 110%; font-weight: bold;">CaculateStackFrame</span>(<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">char</span> *<span style="color: #dbdb95;">byteCode</span>, <span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span> <span style="color: #dbdb95;">codeSize</span>)
{
  <span style="color: #34cae2; font-weight: bold;">char</span> <span style="color: #dbdb95;">shift</span>, <span style="color: #dbdb95;">left</span>, <span style="color: #dbdb95;">right</span>;
  <span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span> <span style="color: #dbdb95;">size</span>;
  <span style="color: #ffad29; font-weight: bold;">if</span> (byteCode[0] == 0xff &amp;&amp; byteCode[3] == 0xd1)
    {
      shift = byteCode[2] &amp; 0xc0;
      left = byteCode[2] &amp; 0x3f;
      right = (byteCode[1] &amp; 0xfc) &gt;&gt; 2;

      size = (left &lt;&lt; 6) + right;
      <span style="color: #ffad29; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>shift)
        size = (<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span>)size;
      <span style="color: #ffad29; font-weight: bold;">else</span>
        size = (<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span>)(size &lt;&lt; 12);

      printf(<span style="color: #e67128;">"size not return in hex(size): %x\n"</span>, size);
    }
  <span style="color: #ffad29; font-weight: bold;">if</span> (byteCode[4] == 0xff &amp;&amp; byteCode[7] == 0xd1)
    {
      <span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span> <span style="color: #dbdb95;">tmp</span>;
      shift = byteCode[6] &amp; 0xc0;
      left = byteCode[6] &amp; 0x3f;
      right = (byteCode[5] &amp; 0xfc) &gt;&gt; 2;

      tmp = (left &lt;&lt; 6) + right;
      <span style="color: #ffad29; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>shift)
        tmp = (<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span>)tmp;
      <span style="color: #ffad29; font-weight: bold;">else</span>
        tmp = (<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span>)(tmp &lt;&lt; 12);
      printf(<span style="color: #e67128;">"size not return in hex(tmp): %x\n"</span>,tmp);

      size += tmp;
    }
  <span style="color: #ffad29; font-weight: bold;">return</span> size;
}
</pre>
</div>
<p>
byteCode是传进来的机器指令，而codeSize暂时未用到。ARM64开栈最多两条操作栈指针的sub指令，所以：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffad29; font-weight: bold;">if</span> (byteCode[0] == 0xff &amp;&amp; byteCode[3] == 0xd1)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffad29; font-weight: bold;">if</span> (byteCode[4] == 0xff &amp;&amp; byteCode[7] == 0xd1)
</pre>
</div>
<p>
判断了函数代码段开头两句是否是开栈指令。我们仅分析第一条指令提取栈大小的实现逻辑，第二条类似。
</p>

<p>
注意ARM64默认是小端架构，所以低字节在低地址端，高字节在高地址端。为了确定第22，23比特是否置位，我们用byte2与0xc0作与运算，0xc0来源是二进制11000000。
</p>
<div class="org-src-container">
<pre class="src src-c">shift = byteCode[2] &amp; 0xc0;
</pre>
</div>

<p>
接着取出了立即数的高六个比特位，将byte2与0x3f作与运算，0x3f的来源是二进制00111111。注意最后这六个比特需要左移6位，因为前述的0x3f与运算丢弃了六位。
</p>
<div class="org-src-container">
<pre class="src src-c">left = byteCode[2] &amp; 0x3f;
</pre>
</div>

<p>
然后类似的取出低六比特位，注意最后要右移两位。
</p>
<div class="org-src-container">
<pre class="src src-c">right = (byteCode[1] &amp; 0xfc) &gt;&gt; 2;
</pre>
</div>

<p>
最后根据是否需要扩大2**12倍来计算最终栈大小。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffad29; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>shift)
  size = (<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span>)size;
<span style="color: #ffad29; font-weight: bold;">else</span>
  size = (<span style="color: #34cae2; font-weight: bold;">unsigned</span> <span style="color: #34cae2; font-weight: bold;">int</span>)(size &lt;&lt; 12);
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cauchy</p>
<p class="date">Created: 2019-03-13 Wed 15:48</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
