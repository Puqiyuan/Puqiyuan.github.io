#+TITLE: 协程切换实现
#+AUTHOR: Cauchy
#+EMAIL: pqy7172@gmail.com
#+OPTIONS: ^:nil
#+HTML_HEAD: <link rel="stylesheet" href="https://cs3.swfu.edu.cn/~puqiyuan/org-manual.css" type="text/css">
在X86、X86-64平台上协程切换已得到实现的情况下，本文打算在ARM32、ARM64平台上实现同样的功能。在
文尾还将介绍一种在已知机器指令的情况下如何获得栈大小的方法。

* 协程概念
进程是资源分配的基本单位，这些资源包括内存空间，文件表，外部设备等，而线程是CPU调度的基本
单位。

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的上下文和栈。协程调度
切换时，将寄存器上下文和栈保存到其它地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，
直接操作栈则基本没有内核切换的开销，所以上下文切换用时很少。注意本文在进行这些切换
操作时并不涉及段的变化。

协程切换是用户空间的事，通过避免通常的切换陷入内核而带来的时间开销，这种切换较传统的上下文
切换具有较高的效率。

* 架构介绍
本节将对X86、X86-64、ARM32、ARM64几种平台逐一进行介绍。当然完全的介绍一种体系结构超出了本
文的范围，如果读者对此有兴趣，请参考相应官方手册。我仅关心之于我的目的所需要的体系结构的背
景知识。这些背景知识包括寄存器介绍，调用惯例，常用指令。

寄存器包括通用寄存器和特殊寄存器，一般架构层面会规定出哪些寄存器是特殊的，另一方面，编译器
也会说明一些通用寄存器来作为特别的目的。在操作这些特殊寄存器时要特别注意。

调用惯例作出了调用者（caller）和被调用者（callee）之间的一系列约定，这些约定包括参数如何传
递，哪些寄存器被调用者可以覆盖，被调用者的局部变量应存于何处，结果应如何返回等。之于协程切
换的目的，仅需关心参数如何传递并且只有一个参数的情况。

本文所涉及的四个平台常用指令都大同小异，下文具体到某个平台时再作详细介绍。

CPU架构经常的被分为复杂指令集（[[https://en.wikipedia.org/wiki/Complex_instruction_set_computer][CISC]]）与精简指令集（[[https://en.wikipedia.org/wiki/Reduced_instruction_set_computer][RISC]]）。常见的复杂指令集体系结构包括X86、
X86-64。常见的精简指令集包括ARM系列。二者在设计指令集时是完全相反的思路，CISC希望能在一个
时钟周期内完成更多的事情，而RISC希望做更少的事情。这样CISC的指令集会较复杂，硬件电路设计会
变得很复杂，但对于汇编程序编写较容易，而RISC具有相反的特点。在后文的[[编码实现][编码实现]]一节我们会看到这些
不同的指令集设计哲学是如何影响到我们的汇编程序编写。网上有许多关于这二者设计思想有意思的讨
论，可Google"cisc vs risc"。

以下针对体系结构的介绍仅涉及我们所需要的体系结构知识，其所述理论仅是相应体系结构的一个子集。
** X86
本文所指X86具体为Intel 8086系列，这些CPU拥有32位字宽。
- 寄存器：包括八个通用寄存器eax、ebx、ecx、edx、esi、edi、ebp、esp。一个特殊寄存器eip用来指向当前
  所要运行的指令。通常编译器会赋予某些通用寄存器以特殊的用途，但体系结构层面并未如此强制要
  求，这一点下面的其它体系结类似。这些由编译器指明的特殊寄存器的常见用途包括：
  - esp：栈指针，指示栈顶在何处。
  - ebp：指示栈基址。
- 调用惯例：参数被压栈。
- 常用指令：
  - movl：在内存与寄存器或寄存器与寄存器之间移动数据。
  - pushl：将内存或某个寄存器的内容压栈。
  - ret：返回调用者。
  - leal：将操作数所指地址而非内容加载到寄存器或内存地址中。
  - subl：将两个操作数做减法。
  - jmp：无条件跳转。

** X86-64
X86-64架构时X86架构的64位版，此架构具有64位机器字宽。
- 寄存器：包括16个通用寄存器rax、rbx、rcx、rdx、rsi、rdi、rbp、rsp、r8、r9、r10、r11、r12、r13、
  r14、r15。一个特殊寄存器rip用来指向当前所要运行的指令。编译器赋予的特别用途的寄存器包括：
  - rsp：栈指针，指示栈顶在何处。
  - rbp：指示栈基址。
- 调用惯例：第一个参数被传往rdi寄存器。
- 常用指令：
  与X86类似，只是后缀l变为q，代表64位，而l代表32位。

** ARM32
此架构是ARM的32位版，ARM V7及以前的版本是为32位。
- 寄存器：包括r0-r10共计11个通用寄存器以及以下的特殊寄存器，括号内为其别名：
  - r11(fp)：栈基址寄存器。
  - r12：存储系统调用的号码。
  - r13(sp)：指示栈顶。
  - r14(lr)：存储返回地址。
  - r15(pc)：程序计数器，指示当前运行的指令。下面是一个关于X86和ARM寄存器的对应表格。
    #+ATTR_HTML: :border 2 :rules all
    | ARM     | 作用       | x86                     |
    |---------+------------+-------------------------|
    | r0      | 通用寄存器 | eax                     |
    | r1-r5   | 通用寄存器 | ebx, ecx, edx, esi, edi |
    | r6-r10  | 通用寄存器 |                         |
    | r11(fp) | 栈基址     | ebp                     |
    | r12     | 系统调用   |                         |
    | r13(sp) | 栈指针     | esp                     |
    | r14(lr) | 链接寄存器 |                         |
    | r15     | 程序计数器 | eip                     |
    
- 调用惯例：第一个参数会被送到r0寄存器。
- 常用指令：
  - str：将寄存器的值存到内存。
  - mov：在两个寄存器间移动值。
  - ldr：将内存中的某个值加载到寄存器。
  - push：将寄存器的值压栈。
  - add：对操作数执行加操作。


** ARM64
ARM V8及以后的版本为64位。
- 寄存器：x0-x30共计31个寄存器。x31依使用环境决定是用作什么目的的寄存器，作为栈时写作sp。
  特殊目的的寄存器包括：
  - x29：栈基址。
  - x30：链接寄存器，用于存放返回地址。

- 调用惯例：第一个参数被传往x0寄存器。
- 常用指令：与ARM32类似，不同的是，ARM64下操作栈用stp和ldp指令并保证操作栈时16字节对齐，而
  不是ARM32的push与pop。返回调用调用者时用ret。
  
    
* 实现原理
本节将概要介绍实现原理，而具体的代码实现细节留待下节。讨论实现时，协程、上下文、任
务它们几者互为同义词。在讨论实现时，我更愿意用任务，而实现程序中多用上下文。

在CPU里定义任务环境：就是所有寄存器的内容。对于任务切换，我们需要保存当前任务环境，并恢复
新任务的任务环境同时切换到新任务去运行。本实现分为两个方式：具有参数和不具有参数的切换。对于
带参的，还需要按照调用惯例把参数传到相应的位置。

当前的任务环境存放到某个内存地址，而在另一个内存地址又存放着新任务的任务环境。当然，任务环
境是一个较大的结构体，因为要存储和恢复的不只是一个寄存器，以上述两个内存地址作为基址，偏移
一定的字节就得到各个寄存器的内容。


* 编码实现
<<编码实现>>
此节将会详细讨论各个平台上的协程切换实现细节。尽管总体原理相似，但具体到实现层面依然有许多
待解决的问题，接下来一一讨论。

** X86
首先需要定义偏移，以定出偏移多少字节是哪个寄存器的内容。
#+INCLUDE: "../coroutineARM64/pub_arch.h" src c:lines "19-27"
其中，COROUTINE_WORD_SIZE是机器字宽，对于X86是4字节。

接下来需要将两个内存地址传递到栈上，以便协程切换时使用，这两个地址是用户给出。以下内联汇编
完成了这个工作：
#+INCLUDE: "../coroutineARM64/pub_coroutine.h" src c:lines "53-56"
关于内联汇编的知识可以参考[[https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html][这里]]。请注意这段代码只是Jmp方式的切换，即新任务不带参运行。先是
开栈，然后先把下一个要运行的任务地址入栈，接下来用来存储当前任务环境的内存地址入栈。

做好了准备工作就可以正式进行切换工作了。

第一步当然是保存当前的任务环境：
#+INCLUDE: "../coroutineARM64/coroutine.S" src asm:lines "32-46"
